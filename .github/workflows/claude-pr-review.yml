name: BlazeCommerce Claude AI Review Bot (Official Action Only)

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_run:
    workflows: ["*"]
    types: [completed]

# Prevent race conditions between concurrent workflow runs
concurrency:
  group: claude-review-${{ github.ref }}
  cancel-in-progress: false

jobs:
  claude-review-official:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    timeout-minutes: 10  # Reduced timeout since official action is more reliable

    outputs:
      success: ${{ steps.review-status.outputs.success }}
      total_resolved_required: ${{ steps.update-tracking.outputs.total_resolved_required }}
      total_resolved_important: ${{ steps.update-tracking.outputs.total_resolved_important }}
      newly_resolved_required: ${{ steps.update-tracking.outputs.newly_resolved_required }}
      newly_resolved_important: ${{ steps.update-tracking.outputs.newly_resolved_important }}

    permissions:
      contents: read
      pull-requests: write
      issues: write
      checks: read
      id-token: write  # Required for anthropics/claude-code-action OIDC token

    steps:
      - name: Validate Organization
        run: |
          if [[ "${{ github.repository_owner }}" != "blaze-commerce" ]]; then
            echo "‚ùå This workflow is only for blaze-commerce repositories"
            exit 1
          fi
          echo "‚úÖ Organization validation passed"

      - name: Check if PR Already Approved and Skip if Minimal Changes
        id: skip-check
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Get PR details
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });

              // Check if PR is already approved
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });

              const approvedReviews = reviews.filter(review => review.state === 'APPROVED');
              const isApproved = approvedReviews.length > 0;

              console.log(`PR approval status: ${isApproved ? 'APPROVED' : 'NOT APPROVED'}`);

              if (isApproved) {
                // Check if recent changes are only workflow/config files
                const { data: files } = await github.rest.pulls.listFiles({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number
                });

                const recentCommits = await github.rest.pulls.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  per_page: 5
                });

                // Get the latest commit
                const latestCommit = recentCommits.data[recentCommits.data.length - 1];
                const commitMessage = latestCommit.commit.message.toLowerCase();

                // Check if this is a workflow/config fix
                const isWorkflowFix = commitMessage.includes('workflow') ||
                                    commitMessage.includes('fix:') ||
                                    commitMessage.includes('claude') ||
                                    files.some(file => file.filename.startsWith('.github/workflows/'));

                if (isWorkflowFix) {
                  console.log('üîÑ Detected workflow/config fix on approved PR - skipping review');
                  core.setOutput('should_skip', 'true');
                  core.setOutput('skip_reason', 'workflow_fix_on_approved_pr');
                  return;
                }
              }

              console.log('‚úÖ Proceeding with normal review process');
              core.setOutput('should_skip', 'false');
            } catch (error) {
              console.log(`‚ö†Ô∏è Error checking PR status: ${error.message}`);
              console.log('‚úÖ Proceeding with normal review process due to error');
              core.setOutput('should_skip', 'false');
            }

      - name: Post Skip Notification
        if: steps.skip-check.outputs.should_skip == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const skipReason = '${{ steps.skip-check.outputs.skip_reason }}';

            const skipMessage = `## üîÑ Claude AI Review Skipped

            **Reason**: Workflow/configuration fix detected on already approved PR

            ### ‚úÖ Status
            - PR is already approved by reviewers
            - Recent changes appear to be workflow/configuration fixes
            - Skipping redundant review to avoid unnecessary processing

            ### üéØ Next Steps
            - PR can be merged when ready
            - If substantial code changes are made, the review will automatically trigger

            *BlazeCommerce Claude AI Review Bot v3.0 - Smart Skip Logic*`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: skipMessage
            });

      - name: Checkout Repository
        if: steps.skip-check.outputs.should_skip != 'true'
        uses: actions/checkout@v4

      - name: Determine Repository Type
        if: steps.skip-check.outputs.should_skip != 'true'
        id: repo-context
        run: |
          repo_name="${{ github.repository }}"

          if [[ "$repo_name" == *"frontend"* ]]; then
            echo "repo_type=nextjs-frontend" >> $GITHUB_OUTPUT
            echo "üéØ Repository type: Next.js Frontend"
          elif [[ "$repo_name" == *"wp-plugin"* ]] || [[ "$repo_name" == *"plugin"* ]]; then
            echo "repo_type=wordpress-plugin" >> $GITHUB_OUTPUT
            echo "üéØ Repository type: WordPress Plugin"
          elif [[ "$repo_name" == *"child"* ]] || [[ "$repo_name" == *"theme"* ]]; then
            echo "repo_type=wordpress-child-theme" >> $GITHUB_OUTPUT
            echo "üéØ Repository type: WordPress Child Theme"
          else
            echo "repo_type=general" >> $GITHUB_OUTPUT
            echo "üéØ Repository type: General"
          fi

      - name: Prepare BlazeCommerce Context
        if: steps.skip-check.outputs.should_skip != 'true'
        id: prepare-context
        uses: actions/github-script@v7
        with:
          script: |
            const repoType = '${{ steps.repo-context.outputs.repo_type }}';

            // Initialize tracking data for this step
            const fs = require('fs');
            const path = require('path');
            const trackingDir = '.github/claude-tracking';
            const trackingFile = path.join(trackingDir, `pr-${context.payload.pull_request.number}-recommendations.json`);

            let trackingData = { resolved_recommendations: { required: [], important: [] } };
            let resolvedRequiredCount = 0;
            let resolvedImportantCount = 0;

            // Load existing tracking data if file exists
            if (fs.existsSync(trackingFile)) {
              try {
                trackingData = JSON.parse(fs.readFileSync(trackingFile, 'utf8'));
                resolvedRequiredCount = trackingData.resolved_recommendations?.required?.length || 0;
                resolvedImportantCount = trackingData.resolved_recommendations?.important?.length || 0;
              } catch (error) {
                console.log(`‚ö†Ô∏è Error loading tracking data: ${error.message}`);
              }
            }

            // Repository-specific prompts for BlazeCommerce standards
            const prompts = {
              'nextjs-frontend': `
                You are reviewing a Next.js/React frontend for BlazeCommerce e-commerce platform.

                Focus on:
                - React component patterns and hooks usage
                - TypeScript type safety and interface design
                - Performance optimization (Core Web Vitals)
                - SEO best practices and meta tag management
                - E-commerce UX patterns and accessibility
                - State management and data fetching patterns
                - Component reusability and maintainability
                - Error boundaries and loading states
                - Mobile responsiveness and cross-browser compatibility
                - Bundle size optimization and code splitting

                Provide categorized feedback:
                üî¥ REQUIRED - Critical issues that must be fixed
                üü° IMPORTANT - Significant improvements needed
                üîµ SUGGESTIONS - Optional enhancements

                Focus on actionable feedback that helps improve code quality, security, and maintainability.
              `,
              'wordpress-plugin': `
                You are reviewing a WordPress plugin for BlazeCommerce e-commerce platform.

                Focus on:
                - WordPress coding standards and best practices
                - Security considerations (sanitization, validation, nonces)
                - Database operations and query optimization
                - Hook usage and action/filter implementation
                - Plugin architecture and modularity
                - Compatibility with different WordPress versions
                - Performance impact on WordPress sites
                - Proper enqueuing of scripts and styles
                - Internationalization and localization
                - Error handling and logging
                - Admin interface and user experience
                - REST API implementation and security
                - WooCommerce integration best practices

                Provide categorized feedback:
                üî¥ REQUIRED - Critical issues that must be fixed
                üü° IMPORTANT - Significant improvements needed
                üîµ SUGGESTIONS - Optional enhancements

                Focus on actionable feedback that helps improve code quality, security, and maintainability.
              `,
              'wordpress-child-theme': `
                You are reviewing a WordPress child theme for BlazeCommerce e-commerce platform.

                Focus on:
                - Theme hierarchy and WordPress standards
                - CSS organization and maintainability
                - Responsive design and mobile optimization
                - Cross-browser compatibility
                - Performance optimization (CSS/JS)
                - Accessibility compliance (WCAG guidelines)
                - SEO optimization
                - Theme customization best practices
                - PHP template structure and security
                - Asset optimization and loading

                Provide categorized feedback:
                üî¥ REQUIRED - Critical issues that must be fixed
                üü° IMPORTANT - Significant improvements needed
                üîµ SUGGESTIONS - Optional enhancements

                Focus on actionable feedback that helps improve code quality, security, and maintainability.
              `,
              'general': `
                You are reviewing code for BlazeCommerce platform.

                Focus on:
                - Code quality and best practices
                - Potential bugs or issues
                - Performance considerations
                - Security concerns
                - Test coverage and quality
                - Documentation completeness
                - Error handling and edge cases
                - Code maintainability and readability

                Provide categorized feedback:
                üî¥ REQUIRED - Critical issues that must be fixed
                üü° IMPORTANT - Significant improvements needed
                üîµ SUGGESTIONS - Optional enhancements

                Focus on actionable feedback that helps improve code quality, security, and maintainability.
              `
            };

            const selectedPrompt = prompts[repoType] || prompts['general'];

            // Add PR context with tracking information
            let trackingContext = '';
            if (resolvedRequiredCount > 0 || resolvedImportantCount > 0) {
              trackingContext = `

            ## üìã Previous Recommendation Tracking
            **IMPORTANT**: This PR has been updated since the last review. Please consider the following:

            ### ‚úÖ Previously Resolved Items
            - **REQUIRED Issues Resolved**: ${resolvedRequiredCount}
            - **IMPORTANT Issues Resolved**: ${resolvedImportantCount}

            ### üîç Review Instructions
            When providing your review, please:
            1. **Focus on NEW issues** introduced by the latest commits
            2. **Acknowledge resolved items** by noting "‚úÖ Previously identified [issue] has been resolved"
            3. **Clearly distinguish** between new recommendations and any remaining unresolved items
            4. **Use visual indicators**:
               - üÜï NEW: For newly identified issues
               - ‚úÖ RESOLVED: For previously identified issues that are now fixed
               - ‚è≥ PENDING: For previously identified issues that still need attention

            ### üìä Resolved Items Summary
            `;

              if (trackingData.resolved_recommendations?.required?.length > 0) {
                trackingContext += `
            **Previously Resolved REQUIRED Issues:**
            `;
                trackingData.resolved_recommendations.required.forEach((item, index) => {
                  trackingContext += `${index + 1}. ‚úÖ ${item.title || item.description?.substring(0, 100) || 'Resolved issue'}\n`;
                });
              }

              if (trackingData.resolved_recommendations?.important?.length > 0) {
                trackingContext += `
            **Previously Resolved IMPORTANT Issues:**
            `;
                trackingData.resolved_recommendations.important.forEach((item, index) => {
                  trackingContext += `${index + 1}. ‚úÖ ${item.title || item.description?.substring(0, 100) || 'Resolved issue'}\n`;
                });
              }
            }

            const prContext = `

            ## Pull Request Context
            - Repository: ${context.repo.owner}/${context.repo.repo}
            - PR #${context.issue.number}: ${context.payload.pull_request?.title || 'N/A'}
            - Author: ${context.payload.pull_request?.user?.login || 'N/A'}
            - Type: ${repoType}
            ${trackingContext}

            Please provide a comprehensive code review with specific, actionable recommendations.
            Use the visual indicators (üÜï NEW, ‚úÖ RESOLVED, ‚è≥ PENDING) to help developers understand
            the status of each recommendation relative to previous reviews.
            `;

            const fullPrompt = selectedPrompt + prContext;

            // Set output for official action
            core.setOutput('review_prompt', fullPrompt);
            core.setOutput('repo_type', repoType);

            console.log(`‚úÖ BlazeCommerce context prepared for ${repoType} repository`);

      - name: Claude AI Review (Official Action - Attempt 1)
        if: steps.skip-check.outputs.should_skip != 'true'
        id: claude-review-1
        continue-on-error: true
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          direct_prompt: ${{ steps.prepare-context.outputs.review_prompt }}

      - name: Wait Before Retry (30s)
        if: steps.skip-check.outputs.should_skip != 'true' && steps.claude-review-1.outcome == 'failure'
        run: |
          echo "‚è≥ Waiting 30s before retry..."
          sleep 30

      - name: Claude AI Review (Official Action - Attempt 2)
        id: claude-review-2
        if: steps.skip-check.outputs.should_skip != 'true' && steps.claude-review-1.outcome == 'failure'
        continue-on-error: true
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          direct_prompt: ${{ steps.prepare-context.outputs.review_prompt }}

      - name: Wait Before Final Retry (60s)
        if: steps.skip-check.outputs.should_skip != 'true' && steps.claude-review-1.outcome == 'failure' && steps.claude-review-2.outcome == 'failure'
        run: |
          echo "‚è≥ Waiting 60s before final retry..."
          sleep 60

      - name: Claude AI Review (Official Action - Attempt 3)
        id: claude-review-3
        if: steps.skip-check.outputs.should_skip != 'true' && steps.claude-review-1.outcome == 'failure' && steps.claude-review-2.outcome == 'failure'
        continue-on-error: true
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          direct_prompt: ${{ steps.prepare-context.outputs.review_prompt }}

      - name: Determine Review Success
        if: steps.skip-check.outputs.should_skip != 'true'
        id: review-status
        uses: actions/github-script@v7
        with:
          script: |
            const attempt1 = '${{ steps.claude-review-1.outcome }}';
            const attempt2 = '${{ steps.claude-review-2.outcome }}';
            const attempt3 = '${{ steps.claude-review-3.outcome }}';

            if (attempt1 === 'success') {
              console.log('‚úÖ Claude AI review completed successfully on attempt 1');
              core.setOutput('success', 'true');
              core.setOutput('attempt', '1');
            } else if (attempt2 === 'success') {
              console.log('‚úÖ Claude AI review completed successfully on attempt 2');
              core.setOutput('success', 'true');
              core.setOutput('attempt', '2');
            } else if (attempt3 === 'success') {
              console.log('‚úÖ Claude AI review completed successfully on attempt 3');
              core.setOutput('success', 'true');
              core.setOutput('attempt', '3');
            } else {
              console.log('‚ùå All Claude AI review attempts failed');
              core.setOutput('success', 'false');
              core.setOutput('error', 'All attempts failed after 3 retries');
            }

      - name: Post BlazeCommerce Summary
        if: steps.skip-check.outputs.should_skip != 'true' && steps.review-status.outputs.success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const repoType = '${{ steps.prepare-context.outputs.repo_type }}';
            const attempt = '${{ steps.review-status.outputs.attempt }}';

            const summaryComment = `## ü§ñ BlazeCommerce Claude AI Review Summary

            ‚úÖ **Review completed successfully using official Anthropic action**

            ### üìä Review Details
            - **Repository Type**: ${repoType}
            - **Completed on Attempt**: ${attempt}
            - **Review Timestamp**: ${new Date().toISOString().replace('T', ' ').substring(0, 19)} UTC
            - **Authentication**: Official Anthropic GitHub Action (resilient)

            ### üéØ BlazeCommerce Standards Applied
            This review follows BlazeCommerce-specific standards for ${repoType} repositories, including:
            - Security best practices and vulnerability assessment
            - Performance optimization guidelines and recommendations
            - Code quality standards and maintainability patterns
            - E-commerce integration patterns and user experience

            The detailed technical review has been posted above by \`claude[bot]\`.

            *Powered by BlazeCommerce Claude AI Review Bot v3.0 - Official Action Only*`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: summaryComment
            });

      - name: Handle Review Failure
        if: steps.skip-check.outputs.should_skip != 'true' && steps.review-status.outputs.success == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const errorComment = `## ‚ö†Ô∏è BlazeCommerce Claude AI Review Failed

            The automated code review failed after 3 attempts using the official Anthropic action.

            ### üîç Possible Causes
            - Temporary API service overload (Error 529)
            - Network connectivity issues
            - Large PR size exceeding processing limits

            ### üõ†Ô∏è Next Steps
            1. **Wait and Retry**: Push a new commit to trigger another review attempt
            2. **Manual Review**: Request manual code review from team members
            3. **Service Status**: Check [Anthropic Status](https://status.anthropic.com/) for service updates

            ### üìä Attempt Details
            - **All 3 attempts failed** using official Anthropic GitHub Action
            - **Authentication**: Using official action (most reliable method)
            - **Timestamp**: ${new Date().toISOString().replace('T', ' ').substring(0, 19)} UTC

            *BlazeCommerce Claude AI Review Bot v3.0 - Official Action Only*`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: errorComment
            });

      - name: Update Recommendation Tracking
        if: steps.skip-check.outputs.should_skip != 'true' && steps.review-status.outputs.success == 'true'
        id: update-tracking
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            console.log('üìä Updating recommendation tracking based on Claude review...');
            const path = require('path');
            const trackingDir = '.github/claude-tracking';
            const trackingFile = path.join(trackingDir, `pr-${context.payload.pull_request.number}-recommendations.json`);

            let trackingData = {
              pr_number: context.payload.pull_request.number,
              created_at: new Date().toISOString(),
              last_updated: new Date().toISOString(),
              resolved_recommendations: { required: [], important: [] },
              pending_recommendations: { required: [], important: [] },
              commit_history: []
            };

            // Load existing tracking data if file exists with comprehensive error handling
            if (fs.existsSync(trackingFile)) {
              try {
                const fileContent = fs.readFileSync(trackingFile, 'utf8');
                if (fileContent.trim()) {
                  trackingData = JSON.parse(fileContent);
                  trackingData.last_updated = new Date().toISOString();
                  console.log(`üìã Loaded existing tracking data successfully`);
                } else {
                  console.log(`‚ö†Ô∏è Tracking file is empty, using default data structure`);
                }
              } catch (error) {
                console.error(`‚ùå Error loading tracking data: ${error.message}`);
                console.log(`‚ö†Ô∏è Using default tracking data structure due to file corruption`);
                // trackingData already has default structure, so we continue
              }
            } else {
              console.log(`üìã No existing tracking file found, starting with fresh data`);
            }

            // Parse the latest Claude review comment to identify current recommendations
            async function parseLatestClaudeReview() {
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                per_page: 100
              });

              // Find the most recent Claude bot comment
              const claudeComment = comments.data
                .filter(comment => {
                  const isClaudeBot = comment.user.login === 'claude[bot]' ||
                                     comment.user.type === 'Bot' ||
                                     comment.user.login.includes('claude');
                  const hasReviewContent = comment.body && (
                    comment.body.includes('Code Review') ||
                    comment.body.includes('üî¥') ||
                    comment.body.includes('üü°')
                  );
                  return isClaudeBot && hasReviewContent;
                })
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];

              if (!claudeComment) {
                console.log('‚ö†Ô∏è No Claude review comment found');
                return { currentRequired: [], currentImportant: [] };
              }

              let commentBody = claudeComment.body;

              // Input validation and sanitization to prevent ReDoS attacks
              if (!commentBody || typeof commentBody !== 'string') {
                console.log('‚ö†Ô∏è Invalid comment body, using empty string');
                commentBody = '';
              }

              // Limit content size to prevent performance issues
              const MAX_CONTENT_SIZE = 50000; // 50KB limit
              if (commentBody.length > MAX_CONTENT_SIZE) {
                console.log(`‚ö†Ô∏è Large content detected (${commentBody.length} chars), truncating to prevent performance issues`);
                commentBody = commentBody.substring(0, MAX_CONTENT_SIZE);
              }

              // Enhanced input sanitization for security
              commentBody = commentBody
                .replace(/<script[\s\S]*?<\/script>/gi, '')
                .replace(/javascript\s*:/gi, '')
                .replace(/data\s*:/gi, '')
                .replace(/vbscript\s*:/gi, '')
                .replace(/on\w+\s*=\s*["'][^"']*["']/gi, '')
                .replace(/&#x[0-9a-f]+;/gi, '')
                .replace(/&#\d+;/gi, '')
                .replace(/[\x00-\x1f\x7f]/g, ''); // Remove control characters

              // Use safer regex patterns with character limits to prevent ReDoS
              const requiredPattern = /üî¥\s*[^\n]{0,200}?REQUIRED[\s\S]{0,2000}?(?=üü°|üîµ|$)/gi;
              const importantPattern = /üü°\s*[^\n]{0,200}?IMPORTANT[\s\S]{0,2000}?(?=üî¥|üîµ|$)/gi;

              // Safe regex matching with error handling and limits
              let currentRequired = [];
              let currentImportant = [];

              try {
                const requiredMatches = commentBody.match(requiredPattern) || [];
                const importantMatches = commentBody.match(importantPattern) || [];

                // Limit number of matches to prevent performance issues
                const MAX_RECOMMENDATIONS = 50;

                currentRequired = requiredMatches.slice(0, MAX_RECOMMENDATIONS).map((match, index) => ({
                  id: `req_${Date.now()}_${index}`,
                  description: match.trim().substring(0, 1000), // Limit description length
                  identified_at: new Date().toISOString(),
                  status: 'pending'
                }));

                currentImportant = importantMatches.slice(0, MAX_RECOMMENDATIONS).map((match, index) => ({
                  id: `imp_${Date.now()}_${index}`,
                  description: match.trim().substring(0, 1000), // Limit description length
                  identified_at: new Date().toISOString(),
                  status: 'pending'
                }));
              } catch (error) {
                console.error(`‚ùå Error parsing recommendations: ${error.message}`);
                console.log('‚ö†Ô∏è Using empty recommendation lists due to parsing error');
                currentRequired = [];
                currentImportant = [];
              }

              console.log(`üìã Found ${currentRequired.length} current REQUIRED and ${currentImportant.length} current IMPORTANT recommendations`);

              return { currentRequired, currentImportant };
            }

            // Update tracking data with comprehensive error handling
            let currentRequired = [];
            let currentImportant = [];

            try {
              const result = await parseLatestClaudeReview();
              currentRequired = result.currentRequired;
              currentImportant = result.currentImportant;
            } catch (error) {
              console.error(`‚ùå Error parsing Claude review: ${error.message}`);
              console.log('‚ö†Ô∏è Continuing with empty recommendation lists due to parsing error');
              // Set default empty arrays to prevent undefined errors
              currentRequired = [];
              currentImportant = [];
            }

            // Identify resolved items (previously pending but not in current review)
            const previouslyPendingRequired = trackingData.pending_recommendations?.required || [];
            const previouslyPendingImportant = trackingData.pending_recommendations?.important || [];

            // Find items that were pending but are no longer mentioned (resolved)
            const newlyResolvedRequired = previouslyPendingRequired.filter(prevItem =>
              !currentRequired.some(currItem =>
                currItem.description.includes(prevItem.description?.substring(0, 50)) ||
                prevItem.description?.includes(currItem.description.substring(0, 50))
              )
            );

            const newlyResolvedImportant = previouslyPendingImportant.filter(prevItem =>
              !currentImportant.some(currItem =>
                currItem.description.includes(prevItem.description?.substring(0, 50)) ||
                prevItem.description?.includes(currItem.description.substring(0, 50))
              )
            );

            // Update tracking data
            trackingData.resolved_recommendations.required.push(...newlyResolvedRequired.map(item => ({
              ...item,
              resolved_at: new Date().toISOString(),
              status: 'resolved'
            })));

            trackingData.resolved_recommendations.important.push(...newlyResolvedImportant.map(item => ({
              ...item,
              resolved_at: new Date().toISOString(),
              status: 'resolved'
            })));

            // Update pending recommendations with current ones
            trackingData.pending_recommendations.required = currentRequired;
            trackingData.pending_recommendations.important = currentImportant;

            // Update metadata
            trackingData.last_updated = new Date().toISOString();
            trackingData.last_review_at = new Date().toISOString();

            // Ensure tracking directory exists before writing with error handling
            try {
              if (!fs.existsSync(trackingDir)) {
                fs.mkdirSync(trackingDir, { recursive: true });
                console.log(`üìÅ Created tracking directory: ${trackingDir}`);
              }

              // Save updated tracking data with error handling
              fs.writeFileSync(trackingFile, JSON.stringify(trackingData, null, 2));
              console.log(`‚úÖ Tracking data saved successfully to ${trackingFile}`);
            } catch (error) {
              console.error(`‚ùå Error saving tracking data: ${error.message}`);
              console.log('‚ö†Ô∏è Continuing without saving tracking data - this will not affect workflow functionality');
            }

            console.log(`‚úÖ Tracking updated: ${newlyResolvedRequired.length} newly resolved REQUIRED, ${newlyResolvedImportant.length} newly resolved IMPORTANT`);
            console.log(`üìä Current status: ${currentRequired.length} pending REQUIRED, ${currentImportant.length} pending IMPORTANT`);

            // Set outputs for the auto-approve job
            core.setOutput('newly_resolved_required', newlyResolvedRequired.length.toString());
            core.setOutput('newly_resolved_important', newlyResolvedImportant.length.toString());
            core.setOutput('total_resolved_required', trackingData.resolved_recommendations.required.length.toString());
            core.setOutput('total_resolved_important', trackingData.resolved_recommendations.important.length.toString());

      - name: Commit Tracking Data
        if: steps.skip-check.outputs.should_skip != 'true' && steps.review-status.outputs.success == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .github/claude-tracking/
          if git diff --staged --quiet; then
            echo "üìã No tracking changes to commit"
          else
            git commit -m "chore: update Claude AI recommendation tracking data [skip ci]"
            git push
            echo "‚úÖ Tracking data committed and pushed"
          fi

  auto-approve:
    needs: claude-review-official
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5

    permissions:
      contents: read
      pull-requests: write
      checks: read

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4



      - name: Check for Approval Revocation
        id: check-revocation
        uses: actions/github-script@v7
        with:
          script: |
            console.log('üîç Checking if approval revocation is needed...');

            // Helper function to parse Claude review comments for recommendations
            async function parseClaudeRecommendations(github, context) {
              const requiredItems = [];
              const importantItems = [];

              try {
                // Get PR comments with pagination support
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  per_page: 100
                });

                // Find the most recent Claude bot comment
                const claudeComment = comments.data
                  .filter(comment => {
                    const isClaudeBot = comment.user.login === 'claude[bot]' ||
                                       comment.user.type === 'Bot' ||
                                       comment.user.login.includes('claude');
                    const hasReviewContent = comment.body && (
                      comment.body.includes('Code Review') ||
                      comment.body.includes('üî¥') ||
                      comment.body.includes('üü°') ||
                      comment.body.includes('REQUIRED') ||
                      comment.body.includes('IMPORTANT')
                    );
                    return isClaudeBot && hasReviewContent;
                  })
                  .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];

                if (claudeComment) {
                  let commentBody = claudeComment.body;

                  // Input validation and sanitization
                  if (!commentBody || typeof commentBody !== 'string') {
                    return { requiredItems, importantItems };
                  }

                  // Limit content size and sanitize
                  const MAX_CONTENT_SIZE = 50000;
                  if (commentBody.length > MAX_CONTENT_SIZE) {
                    commentBody = commentBody.substring(0, MAX_CONTENT_SIZE);
                  }

                  commentBody = commentBody.replace(/<script[^>]*>.*?<\/script>/gi, '')
                                          .replace(/javascript:/gi, '')
                                          .replace(/on\w+\s*=/gi, '');

                  // Enhanced regex patterns for parsing recommendations
                  const requiredPattern = /üî¥\s*(?:.*?)?REQUIRED[\s\S]*?(?=üü°\s*(?:.*?)?(?:IMPORTANT|SUGGESTIONS)|üîµ\s*SUGGESTIONS|$)/gi;
                  const requiredMatches = commentBody.match(requiredPattern) || [];

                  const importantPattern = /üü°\s*(?:.*?)?IMPORTANT[\s\S]*?(?=üî¥\s*(?:.*?)?REQUIRED|üîµ\s*SUGGESTIONS|$)/gi;
                  const importantMatches = commentBody.match(importantPattern) || [];

                  requiredItems.push(...requiredMatches.map(match => match.trim().substring(0, 1000)));
                  importantItems.push(...importantMatches.map(match => match.trim().substring(0, 1000)));

                  console.log(`Found ${requiredItems.length} REQUIRED and ${importantItems.length} IMPORTANT recommendations in latest Claude review`);
                }
              } catch (error) {
                console.error(`Error parsing Claude recommendations: ${error.message}`);
              }

              return { requiredItems, importantItems };
            }

            // Check if PR was previously approved
            async function checkPreviousApproval(github, context) {
              try {
                const reviews = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number
                });

                // Find the most recent approval
                const approvals = reviews.data
                  .filter(review => review.state === 'APPROVED')
                  .sort((a, b) => new Date(b.submitted_at) - new Date(a.submitted_at));

                if (approvals.length > 0) {
                  const latestApproval = approvals[0];
                  console.log(`‚úÖ Found previous approval by ${latestApproval.user.login} at ${latestApproval.submitted_at}`);
                  return {
                    hasApproval: true,
                    approvalId: latestApproval.id,
                    approvedBy: latestApproval.user.login,
                    approvedAt: latestApproval.submitted_at
                  };
                }

                console.log('‚ÑπÔ∏è No previous approvals found');
                return { hasApproval: false };
              } catch (error) {
                console.error(`Error checking previous approvals: ${error.message}`);
                return { hasApproval: false };
              }
            }

            // Main revocation logic
            const claudeReviewSuccess = '${{ needs.claude-review-official.outputs.success }}' === 'true';

            if (!claudeReviewSuccess) {
              console.log('‚ö†Ô∏è Claude review failed - skipping revocation check');
              core.setOutput('revocation_needed', 'false');
              core.setOutput('reason', 'Claude review failed');
              return { revocationNeeded: false, reason: 'Claude review failed' };
            }

            // Check for previous approval
            const approvalStatus = await checkPreviousApproval(github, context);

            if (!approvalStatus.hasApproval) {
              console.log('‚ÑπÔ∏è No previous approval found - no revocation needed');
              core.setOutput('revocation_needed', 'false');
              core.setOutput('reason', 'No previous approval');
              return { revocationNeeded: false, reason: 'No previous approval' };
            }

            // Parse current Claude recommendations
            const { requiredItems, importantItems } = await parseClaudeRecommendations(github, context);

            // Check if there are new critical recommendations
            const hasNewCriticalIssues = requiredItems.length > 0 || importantItems.length > 0;

            if (hasNewCriticalIssues) {
              console.log(`üö® APPROVAL REVOCATION NEEDED: Found ${requiredItems.length} REQUIRED and ${importantItems.length} IMPORTANT recommendations`);

              core.setOutput('revocation_needed', 'true');
              core.setOutput('required_count', requiredItems.length.toString());
              core.setOutput('important_count', importantItems.length.toString());
              core.setOutput('required_items', JSON.stringify(requiredItems));
              core.setOutput('important_items', JSON.stringify(importantItems));
              core.setOutput('approved_by', approvalStatus.approvedBy);
              core.setOutput('approved_at', approvalStatus.approvedAt);
              core.setOutput('reason', 'New critical recommendations found');

              return {
                revocationNeeded: true,
                requiredCount: requiredItems.length,
                importantCount: importantItems.length,
                approvedBy: approvalStatus.approvedBy,
                approvedAt: approvalStatus.approvedAt
              };
            } else {
              console.log('‚úÖ No new critical recommendations found - approval remains valid');
              core.setOutput('revocation_needed', 'false');
              core.setOutput('reason', 'No new critical issues');
              return { revocationNeeded: false, reason: 'No new critical issues' };
            }

      - name: Revoke Approval if Needed
        if: steps.check-revocation.outputs.revocation_needed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('üö® Revoking previous approval due to new critical recommendations...');

            const requiredCount = '${{ steps.check-revocation.outputs.required_count }}';
            const importantCount = '${{ steps.check-revocation.outputs.important_count }}';
            const requiredItems = JSON.parse('${{ steps.check-revocation.outputs.required_items }}');
            const importantItems = JSON.parse('${{ steps.check-revocation.outputs.important_items }}');
            const approvedBy = '${{ steps.check-revocation.outputs.approved_by }}';
            const approvedAt = '${{ steps.check-revocation.outputs.approved_at }}';

            // Create REQUEST_CHANGES review to revoke approval
            let reviewBody = `## üö® Approval Revoked - New Critical Issues Detected

            **Previous approval by @${approvedBy} (${new Date(approvedAt).toLocaleString()}) has been automatically revoked.**

            ### üìã Reason for Revocation
            New commits have introduced critical issues that must be addressed before this PR can be approved again.

            `;

            if (requiredCount > 0) {
              reviewBody += `### üî¥ REQUIRED Issues (${requiredCount})
              **These critical issues must be fixed before approval:**

              `;

              requiredItems.forEach((item, index) => {
                const cleanItem = item.replace(/üî¥\s*(?:.*?)?REQUIRED\s*/gi, '').trim();
                reviewBody += `${index + 1}. ${cleanItem.substring(0, 500)}...\n\n`;
              });
            }

            if (importantCount > 0) {
              reviewBody += `### üü° IMPORTANT Issues (${importantCount})
              **These issues should be addressed for code quality:**

              `;

              importantItems.forEach((item, index) => {
                const cleanItem = item.replace(/üü°\s*(?:.*?)?IMPORTANT\s*/gi, '').trim();
                reviewBody += `${index + 1}. ${cleanItem.substring(0, 500)}...\n\n`;
              });
            }

            reviewBody += `
            ### üîÑ Next Steps
            1. Address the REQUIRED issues listed above
            2. Consider addressing the IMPORTANT issues for better code quality
            3. Push new commits with the fixes
            4. The Claude AI Review Bot will automatically re-evaluate for approval

            ### üõ°Ô∏è Security Note
            This automatic approval revocation helps ensure that new commits introducing critical issues don't bypass the review process, maintaining code quality and security standards.

            ---
            *This review was automatically generated by the Claude AI Review Bot's approval revocation system.*
            `;

            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                event: 'REQUEST_CHANGES',
                body: reviewBody
              });

              console.log('‚úÖ Successfully created REQUEST_CHANGES review to revoke approval');

              // Log the revocation for audit purposes
              const revocationLog = {
                timestamp: new Date().toISOString(),
                pr_number: context.payload.pull_request.number,
                action: 'approval_revoked',
                previously_approved_by: approvedBy,
                previously_approved_at: approvedAt,
                revocation_reason: 'new_critical_recommendations',
                required_issues_count: requiredCount,
                important_issues_count: importantCount,
                actor: context.actor,
                workflow_run_id: context.runId
              };

              console.log('üìä REVOCATION AUDIT LOG:', JSON.stringify(revocationLog, null, 2));

            } catch (error) {
              console.error(`‚ùå Failed to create revocation review: ${error.message}`);
              throw error;
            }

      - name: Check Auto-Approval Criteria
        id: check-criteria
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            console.log('üîç Checking auto-approval criteria...');

            // Helper function to parse Claude review comments for recommendations
            async function parseClaudeReviewComments(github, context) {
              const requiredItems = [];
              const importantItems = [];

              try {
                console.log('üîç Parsing Claude review comments for recommendations...');

                // Get PR comments with pagination support
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  per_page: 100
                });

                console.log(`Found ${comments.data.length} comments on PR`);

                // Find Claude bot comment with enhanced detection
                const claudeComment = comments.data.find(comment => {
                  const isClaudeBot = comment.user.login === 'claude[bot]' ||
                                     comment.user.type === 'Bot' ||
                                     comment.user.login.includes('claude');
                  const hasReviewContent = comment.body && (
                    comment.body.includes('Code Review') ||
                    comment.body.includes('üî¥') ||
                    comment.body.includes('üü°') ||
                    comment.body.includes('REQUIRED') ||
                    comment.body.includes('IMPORTANT')
                  );
                  return isClaudeBot && hasReviewContent;
                });

                if (claudeComment) {
                  console.log('‚úÖ Found Claude bot review comment');
                  let commentBody = claudeComment.body;

                  // Input validation and sanitization
                  if (!commentBody || typeof commentBody !== 'string') {
                    console.log('‚ö†Ô∏è Invalid comment body format');
                    return { requiredItems, importantItems };
                  }

                  // Limit content size to prevent performance issues
                  const MAX_CONTENT_SIZE = 50000; // 50KB limit
                  if (commentBody.length > MAX_CONTENT_SIZE) {
                    console.log(`‚ö†Ô∏è Comment body too large (${commentBody.length} chars), truncating to ${MAX_CONTENT_SIZE}`);
                    commentBody = commentBody.substring(0, MAX_CONTENT_SIZE);
                  }

                  // Sanitize content - remove potential script injections
                  commentBody = commentBody.replace(/<script[^>]*>.*?<\/script>/gi, '')
                                          .replace(/javascript:/gi, '')
                                          .replace(/on\w+\s*=/gi, '');

                  // Enhanced regex patterns with proper escaping and validation
                  // Look for üî¥ REQUIRED sections with more specific patterns
                  const requiredPattern = /üî¥\s*(?:.*?)?REQUIRED[\s\S]*?(?=üü°\s*(?:.*?)?(?:IMPORTANT|SUGGESTIONS)|üîµ\s*SUGGESTIONS|$)/gi;
                  const requiredMatches = commentBody.match(requiredPattern) || [];

                  // Look for üü° IMPORTANT sections with more specific patterns
                  const importantPattern = /üü°\s*(?:.*?)?IMPORTANT[\s\S]*?(?=üî¥\s*(?:.*?)?REQUIRED|üîµ\s*SUGGESTIONS|$)/gi;
                  const importantMatches = commentBody.match(importantPattern) || [];

                  // Process and sanitize matches
                  requiredItems.push(...requiredMatches.map(match => {
                    return match.trim().substring(0, 1000); // Limit individual item size
                  }));

                  importantItems.push(...importantMatches.map(match => {
                    return match.trim().substring(0, 1000); // Limit individual item size
                  }));

                  console.log(`Found ${requiredItems.length} REQUIRED recommendations in Claude comments`);
                  console.log(`Found ${importantItems.length} IMPORTANT recommendations in Claude comments`);

                  // Log first few characters of each item for debugging (without sensitive content)
                  requiredItems.forEach((item, index) => {
                    console.log(`REQUIRED ${index + 1}: ${item.substring(0, 100)}...`);
                  });
                  importantItems.forEach((item, index) => {
                    console.log(`IMPORTANT ${index + 1}: ${item.substring(0, 100)}...`);
                  });

                } else {
                  console.log('‚ö†Ô∏è No Claude bot review comment found');
                }
              } catch (error) {
                // Enhanced error handling with specific error types
                if (error.name === 'HttpError' && error.status === 403) {
                  console.error('‚ùå API access denied - check token permissions');
                } else if (error.name === 'HttpError' && error.status === 404) {
                  console.error('‚ùå PR or comments not found');
                } else if (error.name === 'RequestError') {
                  console.error('‚ùå Network error accessing GitHub API');
                } else {
                  console.error(`‚ùå Critical error parsing Claude comments: ${error.message}`);
                }

                // Don't throw - return empty arrays to allow workflow to continue
                console.log('‚ö†Ô∏è Continuing with empty recommendation lists due to parsing error');
              }

              return { requiredItems, importantItems };
            }

            // Step 1: Validate token and permissions
            try {
              const currentUser = await github.rest.users.getAuthenticated();
              console.log(`üîê Authenticated as: ${currentUser.data.login}`);

              // Validate token scope and permissions
              if (!currentUser.data.login) {
                throw new Error('‚ùå Invalid authentication token - no user information available');
              }
            } catch (error) {
              console.error(`‚ùå Token validation failed: ${error.message}`);
              core.setOutput('action_type', 'skip_approval');
              core.setOutput('reason', 'Authentication token validation failed');
              // Set default status outputs for accurate status reporting
              core.setOutput('all_required_addressed', 'false');
              core.setOutput('all_important_addressed', 'false');
              core.setOutput('pending_required_count', '0');
              core.setOutput('pending_important_count', '0');
              core.setOutput('pending_required_items', '[]');
              core.setOutput('pending_important_items', '[]');
              return { action: 'skip_approval', reason: 'Token validation failed' };
            }

            // Step 2: Check if approval was just revoked
            const revocationNeeded = '${{ steps.check-revocation.outputs.revocation_needed }}' === 'true';
            if (revocationNeeded) {
              console.log('üö® Approval was just revoked due to new critical recommendations - skipping auto-approval');
              core.setOutput('action_type', 'skip_approval');
              core.setOutput('reason', 'Approval revoked due to new critical recommendations');
              core.setOutput('all_required_addressed', 'false');
              core.setOutput('all_important_addressed', 'false');
              core.setOutput('pending_required_count', '${{ steps.check-revocation.outputs.required_count }}');
              core.setOutput('pending_important_count', '${{ steps.check-revocation.outputs.important_count }}');
              core.setOutput('pending_required_items', '${{ steps.check-revocation.outputs.required_items }}');
              core.setOutput('pending_important_items', '${{ steps.check-revocation.outputs.important_items }}');
              return { action: 'skip_approval', reason: 'Approval revoked due to new critical recommendations' };
            }

            // Step 3: Check if Claude review succeeded
            const claudeReviewSuccess = '${{ needs.claude-review-official.outputs.success }}' === 'true';
            console.log(`Claude Review Success: ${claudeReviewSuccess}`);

            // Step 4: Check GitHub Actions status
            try {
              const checkRuns = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request?.head?.sha
              });

              const failedChecks = checkRuns.data.check_runs.filter(check =>
                check.conclusion === 'failure' || check.conclusion === 'cancelled'
              );

              if (failedChecks.length > 0) {
                console.log(`‚ùå Found ${failedChecks.length} failed checks - auto-approval blocked`);
                core.setOutput('action_type', 'skip_approval');
                core.setOutput('reason', 'Failed GitHub Actions checks');
                core.setOutput('failed_checks_count', failedChecks.length.toString());
                // Set default status outputs for accurate status reporting
                core.setOutput('all_required_addressed', 'false');
                core.setOutput('all_important_addressed', 'false');
                core.setOutput('pending_required_count', '0');
                core.setOutput('pending_important_count', '0');
                core.setOutput('pending_required_items', '[]');
                core.setOutput('pending_important_items', '[]');
                return { action: 'skip_approval', reason: 'Failed checks' };
              }
            } catch (error) {
              console.log(`‚ö†Ô∏è Could not check GitHub Actions status: ${error.message}`);
            }

            // Step 3: Enhanced tracking file analysis with REQUIRED recommendation checking
            const trackingFile = '.github/CLAUDE_REVIEW_TRACKING.md';
            let trackingStatus = 'not-found';
            let requiredRecommendationsStatus = { allAddressed: true, pendingItems: [] };
            let importantRecommendationsStatus = { allAddressed: true, pendingItems: [] };

            console.log(`üîç Starting recommendation analysis for PR #${context.payload.pull_request?.number}`);
            console.log(`üìÅ Tracking file path: ${trackingFile}`);

            try {
              if (!fs.existsSync(trackingFile)) {
                console.log('‚ö†Ô∏è Tracking file not found - parsing Claude review comments directly');

                // Parse Claude review comments for recommendations
                const { requiredItems, importantItems } = await parseClaudeReviewComments(github, context);

                if (requiredItems.length > 0) {
                  requiredRecommendationsStatus.allAddressed = false;
                  requiredRecommendationsStatus.pendingItems = requiredItems;
                  console.log(`‚ùå Found ${requiredItems.length} unaddressed REQUIRED recommendations in Claude comments`);
                }

                if (importantItems.length > 0) {
                  importantRecommendationsStatus.allAddressed = false;
                  importantRecommendationsStatus.pendingItems = importantItems;
                  console.log(`‚ùå Found ${importantItems.length} unaddressed IMPORTANT recommendations in Claude comments`);
                }

                trackingStatus = 'parsed-from-comments';
                console.log(`‚úÖ Successfully parsed recommendations from Claude comments`);
              }

              const trackingContent = fs.readFileSync(trackingFile, 'utf8');
              console.log('üìÑ Tracking file found, analyzing content...');

              // Check for overall completion indicators
              if (trackingContent.includes('All critical and important recommendations implemented') ||
                  trackingContent.includes('Implementation Rate: 100%') ||
                  trackingContent.includes('Status: All Claude AI bot recommendations successfully implemented')) {
                trackingStatus = 'complete';
                console.log('‚úÖ Tracking file indicates complete implementation');
              } else {
                trackingStatus = 'incomplete';
                console.log('‚ö†Ô∏è Tracking file indicates incomplete implementation, checking specific recommendations...');

                // Enhanced parsing: Check REQUIRED recommendations status
                const requiredPattern = /üî¥.*REQUIRED.*\(([^)]+)\)/g;
                const requiredMatches = [...trackingContent.matchAll(requiredPattern)];

                console.log(`Found ${requiredMatches.length} REQUIRED recommendation(s)`);

                for (const match of requiredMatches) {
                  const status = match[1];
                  const fullMatch = match[0];
                  console.log(`Checking REQUIRED item: ${fullMatch.substring(0, 100)}...`);
                  console.log(`Status: ${status}`);

                  if (!status.includes('‚úÖ') && !status.includes('All Fixed') && !status.includes('Completed')) {
                    requiredRecommendationsStatus.allAddressed = false;
                    requiredRecommendationsStatus.pendingItems.push(fullMatch);
                    console.log(`‚ùå REQUIRED item not addressed: ${fullMatch.substring(0, 80)}...`);
                  } else {
                    console.log(`‚úÖ REQUIRED item addressed: ${fullMatch.substring(0, 80)}...`);
                  }
                }

                // Check IMPORTANT recommendations status
                const importantPattern = /üü°.*IMPORTANT.*\(([^)]+)\)/g;
                const importantMatches = [...trackingContent.matchAll(importantPattern)];

                console.log(`Found ${importantMatches.length} IMPORTANT recommendation(s)`);

                for (const match of importantMatches) {
                  const status = match[1];
                  const fullMatch = match[0];
                  console.log(`Checking IMPORTANT item: ${fullMatch.substring(0, 100)}...`);
                  console.log(`Status: ${status}`);

                  if (!status.includes('‚úÖ') && !status.includes('All Fixed') && !status.includes('Completed')) {
                    importantRecommendationsStatus.allAddressed = false;
                    importantRecommendationsStatus.pendingItems.push(fullMatch);
                    console.log(`‚ùå IMPORTANT item not addressed: ${fullMatch.substring(0, 80)}...`);
                  } else {
                    console.log(`‚úÖ IMPORTANT item addressed: ${fullMatch.substring(0, 80)}...`);
                  }
                }
              }
            } catch (error) {
              console.log(`‚ö†Ô∏è Error reading tracking file: ${error.message}`);
              trackingStatus = 'error';
            }

            console.log(`Tracking file status: ${trackingStatus}`);
            console.log(`REQUIRED recommendations all addressed: ${requiredRecommendationsStatus.allAddressed}`);
            console.log(`IMPORTANT recommendations all addressed: ${importantRecommendationsStatus.allAddressed}`);

            // Decision logic with enhanced criteria checking
            if (!requiredRecommendationsStatus.allAddressed) {
              console.log(`‚ùå REQUIRED recommendations not fully addressed - creating disapproval review`);
              console.log(`Pending REQUIRED items: ${requiredRecommendationsStatus.pendingItems.length}`);
              core.setOutput('action_type', 'disapprove');
              core.setOutput('reason', 'REQUIRED recommendations pending');
              core.setOutput('pending_required_count', requiredRecommendationsStatus.pendingItems.length.toString());
              core.setOutput('pending_required_items', JSON.stringify(requiredRecommendationsStatus.pendingItems));
              // Set status outputs for accurate status reporting
              core.setOutput('all_required_addressed', requiredRecommendationsStatus.allAddressed.toString());
              core.setOutput('all_important_addressed', importantRecommendationsStatus.allAddressed.toString());
              return { action: 'disapprove', reason: 'Required items pending', pendingItems: requiredRecommendationsStatus.pendingItems };
            }

            if (!importantRecommendationsStatus.allAddressed) {
              console.log(`‚ùå IMPORTANT recommendations not fully addressed - auto-approval blocked`);
              console.log(`Pending IMPORTANT items: ${importantRecommendationsStatus.pendingItems.length}`);
              core.setOutput('action_type', 'skip_approval');
              core.setOutput('reason', 'IMPORTANT recommendations pending');
              core.setOutput('pending_important_count', importantRecommendationsStatus.pendingItems.length.toString());
              core.setOutput('pending_important_items', JSON.stringify(importantRecommendationsStatus.pendingItems));
              // Set status outputs for accurate status reporting
              core.setOutput('all_required_addressed', requiredRecommendationsStatus.allAddressed.toString());
              core.setOutput('all_important_addressed', importantRecommendationsStatus.allAddressed.toString());
              return { action: 'skip_approval', reason: 'Important items pending', pendingItems: importantRecommendationsStatus.pendingItems };
            }

            // Enhanced audit logging for security and compliance
            const processingEndTime = Date.now();
            const processingStartTime = processingEndTime - 30000; // Approximate start time
            const auditLog = {
              timestamp: new Date().toISOString(),
              pr_number: context.payload.pull_request?.number,
              actor: context.actor,
              event: context.eventName,
              claude_review_success: claudeReviewSuccess,
              required_addressed: requiredRecommendationsStatus.allAddressed,
              important_addressed: importantRecommendationsStatus.allAddressed,
              required_count: requiredRecommendationsStatus.pendingItems.length,
              important_count: importantRecommendationsStatus.pendingItems.length,
              tracking_status: trackingStatus,
              processing_time_ms: processingEndTime - processingStartTime,
              workflow_run_id: context.runId,
              repository: context.repo.repo
            };
            console.log('üìä AUDIT LOG:', JSON.stringify(auditLog, null, 2));

            // Check for dry-run mode
            const isDryRun = process.env.CLAUDE_BOT_DRY_RUN === 'true';
            if (isDryRun) {
              console.log('üß™ DRY-RUN MODE: Auto-approval logic would execute but no actual approval will be performed');
            }

            // Auto-approve ONLY if Claude review succeeded AND all recommendations addressed
            if (claudeReviewSuccess &&
                requiredRecommendationsStatus.allAddressed &&
                importantRecommendationsStatus.allAddressed) {
              console.log('üéâ Auto-approval criteria met: Claude review succeeded AND all recommendations addressed!');
              console.log(`üìã APPROVAL DECISION: PR #${context.payload.pull_request?.number} ${isDryRun ? 'would be approved' : 'approved'} by ${context.actor} at ${new Date().toISOString()}`);

              core.setOutput('action_type', isDryRun ? 'dry_run_approve' : 'approve');
              core.setOutput('claude_success', claudeReviewSuccess.toString());
              core.setOutput('tracking_complete', (trackingStatus === 'complete').toString());
              core.setOutput('all_required_addressed', requiredRecommendationsStatus.allAddressed.toString());
              core.setOutput('all_important_addressed', importantRecommendationsStatus.allAddressed.toString());

              let approvalBasis = [];
              if (claudeReviewSuccess) approvalBasis.push('claude_success');
              if (requiredRecommendationsStatus.allAddressed && importantRecommendationsStatus.allAddressed) approvalBasis.push('recommendations_addressed');
              core.setOutput('approval_basis', approvalBasis.join(','));

              return { action: isDryRun ? 'dry_run_approve' : 'approve', reason: 'Claude review succeeded and all recommendations addressed' };
            } else {
              console.log('‚ùå Auto-approval criteria not met - Claude review must succeed AND all recommendations must be addressed');

              let failureReasons = [];
              if (!claudeReviewSuccess) failureReasons.push('Claude review failed');
              if (!requiredRecommendationsStatus.allAddressed) failureReasons.push('REQUIRED recommendations pending');
              if (!importantRecommendationsStatus.allAddressed) failureReasons.push('IMPORTANT recommendations pending');

              const reason = failureReasons.join(', ');
              console.log(`üìã REJECTION DECISION: PR #${context.payload.pull_request?.number} rejected by auto-approval system at ${new Date().toISOString()}`);
              console.log(`üìã REJECTION REASONS: ${reason}`);

              core.setOutput('action_type', 'skip_approval');
              core.setOutput('reason', reason);
              // Set status outputs for accurate status reporting
              core.setOutput('all_required_addressed', requiredRecommendationsStatus.allAddressed.toString());
              core.setOutput('all_important_addressed', importantRecommendationsStatus.allAddressed.toString());
              core.setOutput('pending_required_count', requiredRecommendationsStatus.pendingItems.length.toString());
              core.setOutput('pending_important_count', importantRecommendationsStatus.pendingItems.length.toString());
              core.setOutput('pending_required_items', JSON.stringify(requiredRecommendationsStatus.pendingItems));
              core.setOutput('pending_important_items', JSON.stringify(importantRecommendationsStatus.pendingItems));
              return { action: 'skip_approval', reason: reason };
            }

      - name: Create Disapproval Review
        if: steps.check-criteria.outputs.action_type == 'disapprove'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_GITHUB_TOKEN }}
          script: |
            console.log('üö´ Creating disapproval review for unaddressed REQUIRED recommendations...');

            const pendingRequiredItems = JSON.parse('${{ steps.check-criteria.outputs.pending_required_items }}');
            const pendingCount = '${{ steps.check-criteria.outputs.pending_required_count }}';

            let disapprovalBody = `## ‚ùå Auto-Approval Blocked - REQUIRED Changes Not Addressed

            This PR cannot be approved because **${pendingCount} REQUIRED recommendation(s)** from Claude AI have not been addressed.

            ### üî¥ Pending REQUIRED Recommendations

            The following critical issues must be resolved before this PR can be approved:

            `;

            // Add each pending REQUIRED item with proper formatting
            pendingRequiredItems.forEach((item, index) => {
              // Extract the main recommendation text (remove status part)
              const cleanItem = item.replace(/\([^)]+\)$/, '').trim();
              disapprovalBody += `${index + 1}. ${cleanItem}\n`;
            });

            disapprovalBody += `
            ### üõ†Ô∏è Next Steps

            1. **Address each REQUIRED recommendation** listed above
            2. **Update the tracking file** (`.github/CLAUDE_REVIEW_TRACKING.md`) to mark items as completed with ‚úÖ
            3. **Push your changes** - the bot will automatically re-evaluate on the next commit
            4. **Verify completion** by ensuring all REQUIRED items show ‚úÖ status in the tracking file

            ### üìã Auto-Approval Criteria

            For automatic approval, **ALL** of the following must be met:
            - ‚úÖ All GitHub Actions checks pass
            - ‚úÖ **All REQUIRED recommendations are addressed** (currently failing)
            - ‚úÖ All IMPORTANT recommendations are addressed
            - ‚úÖ Claude AI review completes successfully

            ### üîÑ Automatic Re-evaluation

            This review will be automatically updated when you push new commits. The bot will re-check all criteria and approve automatically once ALL requirements are met (Claude review success AND all recommendations addressed).

            ---
            *BlazeCommerce Claude AI Review Bot v3.0 - Enhanced Auto-Approval with REQUIRED Recommendation Enforcement*`;

            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                event: 'REQUEST_CHANGES',
                body: disapprovalBody
              });

              console.log(`‚úÖ Disapproval review created successfully for ${pendingCount} pending REQUIRED items`);
            } catch (error) {
              console.log(`‚ùå Failed to create disapproval review: ${error.message}`);

              // Fallback: Create a comment if review creation fails
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `## ‚ö†Ô∏è Disapproval Review Creation Failed

                **Error**: ${error.message}

                **Intended Action**: This PR should be disapproved due to ${pendingCount} unaddressed REQUIRED recommendations.

                **Manual Action Required**: Please review the REQUIRED recommendations in the tracking file and address them before approval.`
              });
            }

      - name: Auto-Approve PR
        if: steps.check-criteria.outputs.action_type == 'approve'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_GITHUB_TOKEN }}
          script: |
            console.log('üéâ Creating approval review - all criteria met...');

            // Debug: Verify we're using the bot token
            const { data: currentUser } = await github.rest.users.getAuthenticated();
            console.log(`üîç Authenticated as: ${currentUser.login}`);

            if (currentUser.login !== 'blazecommerce-claude-ai') {
              throw new Error(`‚ùå Wrong token! Expected blazecommerce-claude-ai, got ${currentUser.login}`);
            }

            const claudeSuccess = '${{ steps.check-criteria.outputs.claude_success }}' === 'true';
            const trackingComplete = '${{ steps.check-criteria.outputs.tracking_complete }}' === 'true';
            const allRequiredAddressed = '${{ steps.check-criteria.outputs.all_required_addressed }}' === 'true';
            const allImportantAddressed = '${{ steps.check-criteria.outputs.all_important_addressed }}' === 'true';
            const approvalBasis = '${{ steps.check-criteria.outputs.approval_basis }}';

            let approvalBody = `## ü§ñ BlazeCommerce Claude AI Auto-Approval

            ‚úÖ **All auto-approval criteria have been met**

            ### üìä Approval Basis
            `;

            if (claudeSuccess) {
              approvalBody += `- ‚úÖ Claude AI review completed successfully using official action\n`;
            }
            if (trackingComplete) {
              approvalBody += `- ‚úÖ All recommendations from tracking file implemented\n`;
            }
            if (allRequiredAddressed && allImportantAddressed) {
              approvalBody += `- ‚úÖ All REQUIRED and IMPORTANT recommendations addressed\n`;
            }

            approvalBody += `- ‚úÖ All GitHub Actions checks passed

            ### üéØ Enhanced Quality Assurance
            This PR has been automatically approved using **enhanced criteria validation**:
            - ‚úÖ **REQUIRED Recommendations**: All critical issues resolved
            - ‚úÖ **IMPORTANT Recommendations**: All significant improvements implemented
            - ‚úÖ **Automated Code Review**: Successful analysis completion
            - ‚úÖ **Continuous Integration**: All checks passed
            - ‚úÖ **BlazeCommerce Standards**: Full compliance verified

            ### üîß Technical Details
            - **Authentication Method**: Official Anthropic GitHub Action
            - **Approval Timestamp**: ${new Date().toISOString().replace('T', ' ').substring(0, 19)} UTC
            - **Review System**: BlazeCommerce Claude AI Review Bot v3.0 (Enhanced)
            - **Criteria Basis**: ${approvalBasis}
            - **Validation Level**: REQUIRED + IMPORTANT recommendations

            *This approval demonstrates that all enhanced quality gates have been satisfied, including specific validation of Claude AI recommendations.*`;

            try {
              // First, check if we can access the PR
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });

              console.log(`üìã PR Details: #${pr.number} by ${pr.user.login}, state: ${pr.state}`);

              // Check if PR is from the same user as the bot
              if (pr.user.login === currentUser.login) {
                throw new Error('‚ùå Cannot approve own PR - GitHub security restriction');
              }

              // Attempt the approval
              // Try direct approval first
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  event: 'APPROVE',
                  body: approvalBody
                });
                console.log('‚úÖ Direct approval successful');
              } catch (approvalError) {
                console.log('‚ö†Ô∏è Direct approval failed, trying alternative methods...');

                // Alternative 1: Create a positive review without approval
                try {
                  await github.rest.pulls.createReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.issue.number,
                    event: 'COMMENT',
                    body: `${approvalBody}

                    **Note**: Auto-approval was blocked by GitHub security restrictions. Manual approval required.`
                  });
                  console.log('‚úÖ Created positive review comment instead');
                } catch (commentError) {
                  console.log('‚ùå Review comment also failed:', commentError.message);
                }

                // Alternative 2: Set a status check
                try {
                  await github.rest.repos.createCommitStatus({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    sha: pr.head.sha,
                    state: 'success',
                    context: 'claude-ai-bot/auto-approval-ready',
                    description: 'All criteria met - ready for manual approval'
                  });
                  console.log('‚úÖ Set approval-ready status check');
                } catch (statusError) {
                  console.log('‚ùå Status check also failed:', statusError.message);
                }

                // Re-throw the original error for the outer catch block
                throw approvalError;
              }

              console.log('‚úÖ PR auto-approved successfully with enhanced criteria validation');
            } catch (error) {
              console.log(`‚ùå Failed to auto-approve: ${error.message}`);
              console.log(`üîç Error details:`, error);

              // Determine error type and provide specific guidance
              let errorGuidance = '';
              if (error.message.includes('Resource not accessible')) {
                errorGuidance = `
                ### üîß Possible Solutions:
                1. **Token Issue**: Verify BOT_GITHUB_TOKEN is from blazecommerce-claude-ai account
                2. **Permissions**: Ensure bot has 'Write' repository permissions
                3. **Organization Settings**: Check if org restricts automated approvals
                4. **Branch Protection**: Verify no conflicting protection rules
                `;
              } else if (error.message.includes('own PR')) {
                errorGuidance = `
                ### üîß Solution Required:
                The bot token appears to be associated with the PR author. Use a completely separate bot account.
                `;
              }

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `## ‚ö†Ô∏è Auto-Approval Failed

                **Enhanced criteria were met** but approval action failed: ${error.message}

                ### ‚úÖ Verified Criteria
                - All REQUIRED recommendations addressed
                - All IMPORTANT recommendations addressed
                - All GitHub Actions checks passed

                ${errorGuidance}

                **Manual approval recommended** - all quality gates satisfied.`
              });
            }

      - name: Handle Skip Approval
        if: steps.check-criteria.outputs.action_type == 'skip_approval'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('‚è≥ Posting skip approval status comment...');

            const reason = '${{ steps.check-criteria.outputs.reason }}';
            const failedChecksCount = '${{ steps.check-criteria.outputs.failed_checks_count }}' || '0';
            const pendingRequiredCount = '${{ steps.check-criteria.outputs.pending_required_count }}' || '0';
            const pendingImportantCount = '${{ steps.check-criteria.outputs.pending_important_count }}' || '0';
            const pendingRequiredItems = '${{ steps.check-criteria.outputs.pending_required_items }}' || '[]';
            const pendingImportantItems = '${{ steps.check-criteria.outputs.pending_important_items }}' || '[]';
            const allRequiredAddressed = '${{ steps.check-criteria.outputs.all_required_addressed }}' === 'true';
            const allImportantAddressed = '${{ steps.check-criteria.outputs.all_important_addressed }}' === 'true';
            const revocationNeeded = '${{ steps.check-revocation.outputs.revocation_needed }}' === 'true';
            const revocationReason = '${{ steps.check-revocation.outputs.reason }}' || 'N/A';

            // Get tracking information
            const totalResolvedRequired = parseInt('${{ needs.claude-review-official.outputs.total_resolved_required }}' || '0');
            const totalResolvedImportant = parseInt('${{ needs.claude-review-official.outputs.total_resolved_important }}' || '0');
            const newlyResolvedRequired = parseInt('${{ needs.claude-review-official.outputs.newly_resolved_required }}' || '0');
            const newlyResolvedImportant = parseInt('${{ needs.claude-review-official.outputs.newly_resolved_important }}' || '0');

            // Calculate total items (resolved + pending) for progress ratios
            const totalRequiredItems = totalResolvedRequired + pendingRequiredCount;
            const totalImportantItems = totalResolvedImportant + pendingImportantCount;

            // Calculate progress percentages
            const requiredProgress = totalRequiredItems > 0 ? Math.round((totalResolvedRequired / totalRequiredItems) * 100) : 0;
            const importantProgress = totalImportantItems > 0 ? Math.round((totalResolvedImportant / totalImportantItems) * 100) : 0;

            let statusBody = `## üîç Auto-Approval Status Check

            **Status**: ‚è≥ Criteria not yet met for auto-approval

            **Reason**: ${reason}

            `;

            // Add specific details based on the reason
            if (reason.includes('Failed GitHub Actions checks')) {
              statusBody += `### ‚ùå Failed Checks

              **${failedChecksCount} GitHub Actions check(s) failed**

              Please review the failed checks in the "Checks" tab and resolve any issues before auto-approval can proceed.

              `;
            }

            if (reason.includes('REQUIRED recommendations pending')) {
              statusBody += `### üî¥ Pending REQUIRED Recommendations

              **${pendingRequiredCount} REQUIRED recommendation(s) must be addressed**

              These are critical issues that must be fixed before the PR can be approved:

              `;

              try {
                const pendingItems = JSON.parse(pendingRequiredItems);
                pendingItems.forEach((item, index) => {
                  const cleanItem = item.replace(/\([^)]+\)$/, '').trim();
                  statusBody += `${index + 1}. ${cleanItem.substring(0, 300)}...\n`;
                });
              } catch (e) {
                statusBody += `Please check the Claude review comment for details.\n`;
              }

              statusBody += `\n`;
            }

            if (reason.includes('IMPORTANT recommendations pending')) {
              statusBody += `### üü° Pending IMPORTANT Recommendations

              **${pendingImportantCount} IMPORTANT recommendation(s) not yet addressed**

              While these don't block the PR entirely, addressing them is recommended for auto-approval:

              `;

              try {
                const pendingItems = JSON.parse(pendingImportantItems);
                pendingItems.forEach((item, index) => {
                  const cleanItem = item.replace(/\([^)]+\)$/, '').trim();
                  statusBody += `${index + 1}. ${cleanItem}\n`;
                });
              } catch (e) {
                statusBody += `Please check the tracking file for details.\n`;
              }

              statusBody += `\n`;
            }

            if (reason.includes('No tracking file')) {
              statusBody += `### üìÑ Missing Tracking File

              No Claude AI review tracking file was found, and the Claude review did not complete successfully.

              **Next Steps**:
              1. Ensure Claude AI review completes successfully, OR
              2. Create a tracking file at \`.github/CLAUDE_REVIEW_TRACKING.md\` with recommendation status

              `;
            }

            statusBody += `### ‚úÖ Auto-Approval Criteria

            For automatic approval, **ALL** of the following must be met:
            1. ‚úÖ All GitHub Actions checks pass
            2. ‚úÖ All REQUIRED recommendations are addressed (critical)
            3. ‚úÖ All IMPORTANT recommendations are addressed (recommended)
            4. ‚úÖ Claude AI review completes successfully

            **Note**: Auto-approval now requires Claude review success AND all recommendations addressed (no longer OR logic).

            ### üîÑ Automatic Re-evaluation

            The bot will automatically re-check these criteria on each commit. Once all criteria are met, the PR will be approved automatically.

            ### üìä Current Status Summary
            - **Failed Checks**: ${failedChecksCount > 0 ? `‚ùå ${failedChecksCount} failed` : '‚úÖ All passed'}
            - **REQUIRED Items**: ${pendingRequiredCount > 0 ? `‚ùå ${pendingRequiredCount} pending` : (allRequiredAddressed ? '‚úÖ All addressed' : '‚è≥ Pending analysis')}
            - **IMPORTANT Items**: ${pendingImportantCount > 0 ? `‚è≥ ${pendingImportantCount} pending` : (allImportantAddressed ? '‚úÖ All addressed' : '‚è≥ Pending analysis')}
            - **Claude Review**: ${'${{ needs.claude-review-official.outputs.success }}' === 'true' ? '‚úÖ Completed' : '‚ùå Failed'}
            - **Approval Status**: ${revocationNeeded ? 'üö® Previous approval revoked due to new critical issues' : '‚úÖ No revocation needed'}

            ### üìà Recommendation Tracking Progress
            - **REQUIRED Items**: ${totalRequiredItems > 0 ? `${totalResolvedRequired}/${totalRequiredItems} resolved (${requiredProgress}%) ‚úÖ` : 'No items tracked yet'}
            - **IMPORTANT Items**: ${totalImportantItems > 0 ? `${totalResolvedImportant}/${totalImportantItems} resolved (${importantProgress}%) ‚úÖ` : 'No items tracked yet'}
            ${newlyResolvedRequired > 0 || newlyResolvedImportant > 0 ? `- **Newly Resolved This Update**: ${newlyResolvedRequired} REQUIRED + ${newlyResolvedImportant} IMPORTANT üéâ` : ''}

            ${totalResolvedRequired > 0 || totalResolvedImportant > 0 ? `
            ### üéØ Progress Highlights
            **Great work!** This PR has successfully resolved **${totalResolvedRequired + totalResolvedImportant}** recommendations across multiple commits, demonstrating continuous improvement and attention to code quality.

            **Overall Progress**: ${totalRequiredItems + totalImportantItems > 0 ? `${Math.round(((totalResolvedRequired + totalResolvedImportant) / (totalRequiredItems + totalImportantItems)) * 100)}% of all recommendations resolved` : 'Starting fresh with quality improvements'}
            ` : ''}

            ${revocationNeeded ? `
            ### üö® Approval Revocation Notice

            **A previous approval has been automatically revoked** because new commits introduced critical issues that must be addressed:
            - **REQUIRED Issues**: ${pendingRequiredCount} critical issues found
            - **IMPORTANT Issues**: ${pendingImportantCount} significant issues found

            **Next Steps:**
            1. Review the REQUEST_CHANGES review above for detailed issue descriptions
            2. Address all REQUIRED issues (critical for approval)
            3. Consider addressing IMPORTANT issues (recommended for code quality)
            4. Push new commits with fixes
            5. The bot will automatically re-evaluate for approval

            **Security Note:** This automatic revocation prevents previously-approved code from being merged when new commits introduce security or quality issues.
            ` : ''}

            ---
            *BlazeCommerce Claude AI Review Bot v3.1 - Enhanced Auto-Approval with Automatic Revocation System*`;

            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: statusBody
              });

              console.log(`‚úÖ Skip approval status comment posted - Reason: ${reason}`);
            } catch (error) {
              console.log(`‚ùå Failed to post skip approval comment: ${error.message}`);
            }
