name: "‚úÖ Priority 3: Claude AI Approval Gate"

# This workflow creates a required status check that only passes when Claude AI has approved the PR
# Use this with GitHub Branch Protection Rules to block merging until Claude AI approval
# Priority 3: Runs after Claude AI Review (Priority 2) completes and evaluates official Claude App feedback

on:
  # pull_request:  # DISABLED: Causing auto-approval on every commit push
  #   types: [opened, synchronize, reopened]
  # pull_request_review:  # DISABLED: Causing premature auto-approval on Claude review events
  #   types: [submitted, dismissed]
  # issue_comment:  # DISABLED: Causing premature auto-approval on Claude 'working' comments
  #   types: [created]
  workflow_run:
    workflows: ["ü§ñ Priority 2: Claude AI Code Review"]
    types: [completed]

# Priority 3: Wait for Priority 2 (Claude AI Code Review) to complete before running
concurrency:
  group: priority-3-claude-approval-pr-${{ github.event.pull_request.number || github.event.number || github.run_id }}
  cancel-in-progress: false  # Don't cancel to ensure approval gate completion

jobs:
  # Check if this workflow should run
  check-trigger:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      pr_number: ${{ steps.check.outputs.pr_number }}
      trigger_reason: ${{ steps.check.outputs.trigger_reason }}
    steps:
      - name: Check Trigger Conditions
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            let shouldRun = false;
            let prNumber = null;
            let triggerReason = '';

            if (context.eventName === 'workflow_run') {
              if (context.payload.workflow_run.conclusion) {
                shouldRun = true;
                // Extract PR number from workflow run
                const prMatch = context.payload.workflow_run.head_branch?.match(/^pr-(\d+)/) ||
                               context.payload.workflow_run.display_title?.match(/#(\d+)/);
                prNumber = prMatch ? parseInt(prMatch[1]) : null;
                triggerReason = `Claude review workflow ${context.payload.workflow_run.conclusion}`;
              }
            }
            // DISABLED: issue_comment trigger removed to prevent premature auto-approval
            // else if (context.eventName === 'issue_comment') {
            //   const comment = context.payload.comment.body.toLowerCase();
            //   if (comment.includes('@claude') && context.payload.issue.pull_request) {
            //     shouldRun = true;
            //     prNumber = context.payload.issue.number;
            //     triggerReason = '@claude mention in comment';
            //   }
            // }

            console.log(`Event: ${context.eventName}, Should run: ${shouldRun}, PR: ${prNumber}, Reason: ${triggerReason}`);

            core.setOutput('should_run', shouldRun.toString());
            core.setOutput('pr_number', prNumber?.toString() || '');
            core.setOutput('trigger_reason', triggerReason);

  # Wait for Priority 1 workflow completion before proceeding
  wait-for-claude-review:
    needs: [check-trigger]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: ${{ vars.CLAUDE_DEPENDENCY_CHECK_TIMEOUT || 15 }}
    outputs:
      claude-review-completed: ${{ steps.check-completion.outputs.completed }}
      claude-review-conclusion: ${{ steps.check-completion.outputs.conclusion }}
      should-proceed: ${{ steps.check-completion.outputs.should_proceed }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm install --production

      - name: Check Claude Review Workflow Completion
        id: check-completion
        env:
          GITHUB_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ needs.check-trigger.outputs.pr_number }}
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = '${{ needs.check-trigger.outputs.pr_number }}';
            const triggerReason = '${{ needs.check-trigger.outputs.trigger_reason }}';

            console.log(`DEBUG: Checking Claude Review completion for PR #${prNumber} (${triggerReason})`);

            let shouldProceed = false;
            let completed = false;
            let conclusion = 'unknown';

            try {
              // For workflow_run events, we know the Claude review just completed
              if (context.eventName === 'workflow_run') {
                completed = true;
                conclusion = context.payload.workflow_run.conclusion;
                // Only proceed if the Claude review workflow completed successfully
                shouldProceed = conclusion === 'success';
                console.log(`SUCCESS: Claude review workflow completed via workflow_run event: ${conclusion}`);
                if (!shouldProceed) {
                  console.log(`WARNING: Claude review workflow failed with conclusion: ${conclusion}`);
                }
              } else {
                // For other events (PR synchronize, comments), proceed immediately to check for existing Claude reviews
                // This allows the approval gate to work even if Priority 1 workflow is still running or failed
                console.log(`INFO: Event type ${context.eventName} - proceeding to check for existing Claude reviews`);
                shouldProceed = true;
                completed = true;
                conclusion = 'success';

                // Optional: Still check for recent workflow runs for debugging
                try {
                  const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    per_page: 10
                  });

                  const claudeReviewRun = workflowRuns.workflow_runs.find(run =>
                    run.name === 'Priority 1: Claude AI Code Review' &&
                    (run.head_branch?.includes(`pr-${prNumber}`) ||
                     run.display_title?.includes(`#${prNumber}`) ||
                     run.pull_requests?.some(pr => pr.number == prNumber))
                  );

                  if (claudeReviewRun) {
                    console.log(`DEBUG: Found recent Claude review run: ${claudeReviewRun.status} (${claudeReviewRun.conclusion})`);
                  } else {
                    console.log('DEBUG: No recent Claude review workflow found');
                  }
                } catch (error) {
                  console.log(`DEBUG: Error checking workflow runs: ${error.message}`);
                }
              }
            } catch (error) {
              console.error(`Error checking workflow completion: ${error.message}`);
              // On error, proceed anyway to avoid blocking
              shouldProceed = true;
            }

            core.setOutput('completed', completed.toString());
            core.setOutput('conclusion', conclusion);
            core.setOutput('should_proceed', shouldProceed.toString());

            console.log(`Result: completed=${completed}, conclusion=${conclusion}, shouldProceed=${shouldProceed}`);

  claude-approval-gate:
    needs: [check-trigger, wait-for-claude-review]
    if: needs.wait-for-claude-review.outputs.should-proceed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: ${{ vars.CLAUDE_APPROVAL_GATE_TIMEOUT || 5 }}

    permissions:
      # Minimum required permissions for Claude approval gate workflow
      contents: read          # Required: Read repository content for validation
      pull-requests: read     # Required: Read PR information and reviews
      statuses: write         # Required: Create status checks for merge protection
      checks: write           # Required: Create check runs for approval status
      actions: read           # Required: Read workflow run information for dependencies
      # Security: All other permissions explicitly denied

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm install --production

      - name: Get Current Status
        id: current-status
        env:
          GITHUB_TOKEN: ${{ secrets.BOT_GITHUB_TOKEN }}
          PR_NUMBER: ${{ needs.check-trigger.outputs.pr_number }}
          GITHUB_SHA: ${{ github.event.pull_request.head.sha || github.sha }}
        run: |
          echo "INFO: Getting current Claude AI status..."
          node .github/scripts/claude-status-manager.js get-state
      - name: Enhanced Claude AI Approval Check
        id: check-approval
        env:
          GITHUB_TOKEN: ${{ secrets.BOT_GITHUB_TOKEN }}
          PR_NUMBER: ${{ needs.check-trigger.outputs.pr_number }}
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = '${{ needs.check-trigger.outputs.pr_number }}';
            const triggerReason = '${{ needs.check-trigger.outputs.trigger_reason }}';
            const claudeReviewCompleted = '${{ needs.wait-for-claude-review.outputs.claude-review-completed }}' === 'true';
            const claudeReviewConclusion = '${{ needs.wait-for-claude-review.outputs.claude-review-conclusion }}';

            console.log(`DEBUG: Enhanced approval check for PR #${prNumber}`);
            console.log(`   Trigger: ${triggerReason}`);
            console.log(`   Claude review completed: ${claudeReviewCompleted}`);
            console.log(`   Claude review conclusion: ${claudeReviewConclusion}`);

            let approved = false;
            let reason = 'Unknown status';
            let statusState = 'pending';
            let statusDescription = 'Checking Claude AI approval status...';

            try {
              // Check current status from environment outputs
              const claudeCanMerge = process.env.claude_can_merge === 'true';
              const claudeApprovalState = process.env.claude_approval_state || 'none';
              const claudeReviewState = process.env.claude_review_state || 'none';
              const claudeNeedsReview = process.env.claude_needs_review === 'true';

              console.log(`   Status check results:`);
              console.log(`     - Can merge: ${claudeCanMerge}`);
              console.log(`     - Approval state: ${claudeApprovalState}`);
              console.log(`     - Review state: ${claudeReviewState}`);
              console.log(`     - Needs review: ${claudeNeedsReview}`);

              // Determine approval status based on current state
              if (claudeCanMerge && claudeApprovalState === 'success') {
                approved = true;
                statusState = 'success';
                statusDescription = 'Approved by Claude AI - ready to merge';
                reason = 'Claude AI approved';
              } else if (claudeReviewState === 'failure' || claudeApprovalState === 'failure') {
                approved = false;
                statusState = 'failure';
                statusDescription = 'Manual review required - Claude AI service unavailable';
                reason = 'Claude AI review failed';
              } else if (claudeApprovalState === 'pending' && claudeReviewState === 'success') {
                approved = false;
                statusState = 'pending';
                statusDescription = 'Blocked by required issues - address Claude AI recommendations';
                reason = 'Required issues must be resolved';
              } else if (claudeNeedsReview || claudeReviewState === 'pending') {
                approved = false;
                statusState = 'pending';
                statusDescription = 'Waiting for Claude AI review to complete';
                reason = 'Claude AI review in progress';
              } else {
                // New Architecture: Check for official Claude App review and @blazecommerce-claude-ai approval
                console.log('INFO: Checking for official Claude App review and @blazecommerce-claude-ai approval...');

                // Step 1: Check for official Claude App review comments
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  per_page: 100
                });

                // Enhanced Claude comment detection - look for any comment with FINAL VERDICT
                const claudeAppComments = comments.data.filter(comment => {
                  const isClaudeUser = comment.user.login === 'claude[bot]' ||
                                      comment.user.login === 'claude' ||
                                      comment.user.login.includes('claude');

                  const hasClaudeContent = comment.body && (
                    comment.body.includes('FINAL VERDICT') ||
                    comment.body.includes('### FINAL VERDICT')
                  );

                  const isRelevant = isClaudeUser || hasClaudeContent;

                  if (isRelevant) {
                    console.log(`üéØ FOUND RELEVANT COMMENT: User=${comment.user.login}, HasFinalVerdict=${comment.body.includes('FINAL VERDICT')}`);
                  }

                  return isRelevant;
                });

                console.log(`üîç DETECTION DEBUG: Found ${claudeAppComments.length} Claude App comment(s) out of ${comments.data.length} total comments`);

                // Debug: Log ALL comments for troubleshooting
                console.log('üìù ALL COMMENTS ANALYSIS:');
                comments.data.forEach((comment, index) => {
                  console.log(`Comment ${index + 1}: User=${comment.user.login}, Created=${comment.created_at}`);
                  console.log(`Comment ${index + 1} body contains "FINAL VERDICT":`, comment.body.includes('FINAL VERDICT'));
                  console.log(`Comment ${index + 1} body contains "Status":`, comment.body.includes('Status'));
                  if (comment.body.includes('FINAL VERDICT') || comment.body.includes('Status')) {
                    console.log(`Comment ${index + 1} RELEVANT CONTENT:`, comment.body.substring(0, 500) + '...');
                  }
                });

                // Debug: Log Claude-specific comments
                console.log('ü§ñ CLAUDE COMMENTS ANALYSIS:');
                claudeAppComments.forEach((comment, index) => {
                  console.log(`Claude Comment ${index + 1}: User=${comment.user.login}, Created=${comment.created_at}`);
                  console.log(`Claude Comment ${index + 1} preview:`, comment.body.substring(0, 300) + '...');
                });

                // Step 2: Analyze Claude's feedback using standardized format from CLAUDE.md
                let hasRequiredIssues = false;
                let claudeReviewFound = false;
                let claudeApprovalStatus = 'unknown';

                for (const comment of claudeAppComments) {
                  claudeReviewFound = true;
                  console.log(`Analyzing Claude comment from ${comment.user.login}`);

                  // Check for standardized Final Verdict section with enhanced detection
                  console.log('üîç SEARCHING FOR FINAL VERDICT SECTION...');
                  console.log('üìÑ Comment body length:', comment.body.length);
                  console.log('üìÑ Comment contains "FINAL VERDICT":', comment.body.includes('FINAL VERDICT'));
                  console.log('üìÑ Comment contains "Status":', comment.body.includes('Status'));

                  // Show relevant part of comment for debugging
                  const finalVerdictIndex = comment.body.indexOf('FINAL VERDICT');
                  if (finalVerdictIndex !== -1) {
                    const relevantSection = comment.body.substring(finalVerdictIndex, finalVerdictIndex + 300);
                    console.log('üìÑ FINAL VERDICT SECTION:', relevantSection);
                  }

                  // Primary detection for bracketed format [APPROVED]
                  console.log('üîç Testing Pattern 1: Bracketed format [APPROVED]');
                  let finalVerdictMatch = comment.body.match(/### FINAL VERDICT[\s\S]*?\*\*Status\*\*:\s*\[([^\]]+)\]/i);
                  let detectionMethod = 'bracketed';
                  console.log('üîç Pattern 1 result:', finalVerdictMatch ? finalVerdictMatch[1] : 'NO MATCH');

                  // Fallback to plain text format APPROVED
                  if (!finalVerdictMatch) {
                    console.log('üîç Testing Pattern 2: Plain text format APPROVED');
                    finalVerdictMatch = comment.body.match(/### FINAL VERDICT[\s\S]*?\*\*Status\*\*:\s*([A-Z\s]+)(?:\*\*|\n)/i);
                    detectionMethod = 'plain-text';
                    console.log('üîç Pattern 2 result:', finalVerdictMatch ? finalVerdictMatch[1] : 'NO MATCH');
                  }

                  // Additional fallback for any status after "Status:"
                  if (!finalVerdictMatch) {
                    console.log('üîç Testing Pattern 3: Loose match for any Status');
                    finalVerdictMatch = comment.body.match(/\*\*Status\*\*:\s*([A-Z\s]+?)(?:\s*\*\*|\s*\n)/i);
                    detectionMethod = 'loose-match';
                    console.log('üîç Pattern 3 result:', finalVerdictMatch ? finalVerdictMatch[1] : 'NO MATCH');
                  }

                  if (finalVerdictMatch) {
                    const status = finalVerdictMatch[1].trim();
                    console.log(`Found Final Verdict status: "${status}" using ${detectionMethod} detection`);

                    // Handle both bracketed format [APPROVED] and plain text APPROVED
                    if (status === 'APPROVED' || (status.includes('APPROVED') && !status.includes('CONDITIONAL'))) {
                      claudeApprovalStatus = 'approved';
                      console.log('‚úÖ Claude approved the PR');
                    } else if (status === 'BLOCKED' || status.includes('BLOCKED')) {
                      claudeApprovalStatus = 'blocked';
                      hasRequiredIssues = true;
                      console.log('‚ùå Claude blocked the PR');
                    } else if (status === 'CONDITIONAL APPROVAL' || status.includes('CONDITIONAL')) {
                      claudeApprovalStatus = 'conditional';
                      console.log('‚ö†Ô∏è Claude conditionally approved the PR');
                    } else {
                      console.log(`‚ùì Unknown status format: "${status}"`);
                    }
                  } else {
                    console.log('‚ùå No FINAL VERDICT status found in comment');
                    console.log('Comment preview:', comment.body.substring(0, 500) + '...');
                  }

                  // Also check for Critical Issues section content
                  const criticalIssuesMatch = comment.body.match(/\*\*CRITICAL ISSUES\*\*([\s\S]*?)(?=\*\*STRENGTHS\*\*|\*\*AREAS FOR IMPROVEMENT\*\*|\*\*PERFORMANCE CONSIDERATIONS\*\*|\*\*SECURITY ASSESSMENT\*\*|###|$)/i);
                  if (criticalIssuesMatch) {
                    const criticalContent = criticalIssuesMatch[1].trim();
                    // Check if there's actual content (not just empty lines or dashes)
                    if (criticalContent && criticalContent.length > 10 && !criticalContent.match(/^[\s\-_]*$/)) {
                      hasRequiredIssues = true;
                      console.log('Found content in Critical Issues section');
                    }
                  }

                  // Fallback: Check for legacy patterns if standardized format not found
                  if (claudeApprovalStatus === 'unknown') {
                    if (comment.body.match(/CRITICAL:\s*REQUIRED|REQUIRED.*issues?|must\s+be\s+fixed|critical\s+bugs?/i)) {
                      hasRequiredIssues = true;
                      claudeApprovalStatus = 'blocked';
                      console.log('Found REQUIRED issues using legacy pattern matching');
                    }
                  }
                }

                // Step 3: Check for @blazecommerce-claude-ai approval
                const reviews = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  per_page: 100
                });

                const blazeClaudeApproval = reviews.data.find(review =>
                  review.user.login === 'blazecommerce-claude-ai' && review.state === 'APPROVED'
                );

                // Step 4: Determine approval status based on standardized Claude review format
                if (blazeClaudeApproval) {
                  approved = true;
                  statusState = 'success';
                  statusDescription = 'Approved by @blazecommerce-claude-ai after Claude review';
                  reason = '@blazecommerce-claude-ai approval found';
                  console.log('SUCCESS: Found @blazecommerce-claude-ai approval');
                } else if (claudeReviewFound && claudeApprovalStatus === 'approved') {
                  approved = false;
                  statusState = 'pending';
                  statusDescription = 'Claude approved - waiting for @blazecommerce-claude-ai to approve';
                  reason = 'Claude approved with APPROVED status - awaiting @blazecommerce-claude-ai approval';
                  console.log('INFO: Claude approved - awaiting @blazecommerce-claude-ai approval');
                } else if (claudeReviewFound && claudeApprovalStatus === 'conditional') {
                  approved = false;
                  statusState = 'pending';
                  statusDescription = 'Claude conditionally approved - waiting for @blazecommerce-claude-ai to approve';
                  reason = 'Claude conditionally approved with CONDITIONAL APPROVAL - awaiting @blazecommerce-claude-ai approval';
                  console.log('INFO: Claude conditionally approved - awaiting @blazecommerce-claude-ai approval');
                } else if (claudeReviewFound && (claudeApprovalStatus === 'blocked' || hasRequiredIssues)) {
                  approved = false;
                  statusState = 'failure';
                  statusDescription = 'Blocked by critical issues from Claude review';
                  reason = 'Claude found critical issues that must be addressed (BLOCKED status)';
                  console.log('BLOCKED: Claude found critical issues');
                } else if (claudeReviewFound && !hasRequiredIssues) {
                  approved = false;
                  statusState = 'pending';
                  statusDescription = 'Waiting for @blazecommerce-claude-ai to approve (no critical issues found)';
                  reason = 'Claude reviewed with no critical issues - awaiting @blazecommerce-claude-ai approval';
                  console.log('INFO: Claude review complete with no critical issues - awaiting @blazecommerce-claude-ai approval');
                } else {
                  approved = false;
                  statusState = 'pending';
                  statusDescription = 'Waiting for official Claude App review';
                  reason = 'No Claude App review found yet';
                  console.log('WAITING: No Claude App review found yet');
                }
              }

            } catch (error) {
              console.error(`Error in approval check: ${error.message}`);
              approved = false;
              statusState = 'error';
              statusDescription = `Error checking approval status: ${error.message}`;
              reason = `Error: ${error.message}`;
            }

            // Set outputs
            core.setOutput('approved', approved.toString());
            core.setOutput('reason', reason);
            core.setOutput('status_state', statusState);
            core.setOutput('status_description', statusDescription);

            console.log(`ANALYSIS: Final result: approved=${approved}, state=${statusState}, reason=${reason}`);

      - name: Validate Required Token
        run: |
          if [ -z "${{ secrets.BOT_GITHUB_TOKEN }}" ]; then
            echo "ERROR: BOT_GITHUB_TOKEN secret is required for secure operation"
            echo "Please configure BOT_GITHUB_TOKEN in repository secrets"
            exit 1
          fi
          echo "SUCCESS: BOT_GITHUB_TOKEN is configured"

      - name: Update Approval Status
        env:
          GITHUB_TOKEN: ${{ secrets.BOT_GITHUB_TOKEN }}
          PR_NUMBER: ${{ needs.check-trigger.outputs.pr_number }}
          GITHUB_SHA: ${{ github.event.pull_request.head.sha || github.sha }}
          STATUS_STATE: ${{ steps.check-approval.outputs.status_state }}
          STATUS_DESCRIPTION: ${{ steps.check-approval.outputs.status_description }}
        run: |
          echo "INFO: Updating approval status: $STATUS_STATE - $STATUS_DESCRIPTION"

          # Use status manager to set the approval status
          node -e "
            const { ClaudeStatusManager } = require('./.github/scripts/claude-status-manager.js');
            const statusManager = new ClaudeStatusManager(
              process.env.GITHUB_TOKEN,
              process.env.GITHUB_REPOSITORY.split('/')[0],
              process.env.GITHUB_REPOSITORY.split('/')[1]
            );

            statusManager.setApprovalStatus(
              process.env.GITHUB_SHA,
              process.env.STATUS_STATE,
              process.env.STATUS_DESCRIPTION,
              parseInt(process.env.PR_NUMBER)
            ).then(() => {
              console.log('SUCCESS: Approval status updated successfully');
            }).catch(error => {
              console.error('ERROR: Failed to update approval status:', error.message);
              process.exit(1);
            });
          "

      - name: Post Status Update Comment
        if: needs.check-trigger.outputs.trigger_reason == '@claude mention in comment' || (github.event.action == 'opened' && steps.check-approval.outputs.approved == 'false')
        env:
          PR_NUMBER: ${{ needs.check-trigger.outputs.pr_number }}
          TRIGGER_REASON: ${{ needs.check-trigger.outputs.trigger_reason }}
          APPROVED: ${{ steps.check-approval.outputs.approved }}
          REASON: ${{ steps.check-approval.outputs.reason }}
          STATUS_DESCRIPTION: ${{ steps.check-approval.outputs.status_description }}
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = '${{ env.PR_NUMBER }}';
            const triggerReason = '${{ env.TRIGGER_REASON }}';
            const approved = '${{ env.APPROVED }}' === 'true';
            const reason = '${{ env.REASON }}';
            const statusDescription = '${{ env.STATUS_DESCRIPTION }}';

            let commentBody = '';

            if (triggerReason === '@claude mention in comment') {
              commentBody = [
                "## BOT: Claude AI Re-evaluation Triggered",
                "",
                "Claude AI approval status has been re-evaluated based on your request.",
                "",
                "### ANALYSIS: Current Status",
                `- **Approval Status**: ${approved ? 'SUCCESS: Approved' : 'ERROR: Not Approved'}`,
                `- **Details**: ${statusDescription}`,
                `- **Reason**: ${reason}`,
                "",
                approved ?
                  'COMPLETED: **This PR is now ready to merge** (subject to other branch protection rules).' :
                  'WARNING: **This PR is not yet ready to merge.** Please address any outstanding issues.',
                "",
                "---",
                "*Re-evaluation completed in response to @claude mention*"
              ].join('\n');
            } else {
              // First time comment for new PRs
              commentBody = [
                "## SECURITY: Claude AI Approval Gate",
                "",
                "This PR requires approval from the Claude AI Review Bot before it can be merged.",
                "",
                "### SUMMARY: Current Status",
                `- **Claude AI Approval**: ${approved ? 'SUCCESS: Approved' : 'ERROR: Not yet approved'}`,
                `- **Details**: ${statusDescription}`,
                `- **Merge Status**: ${approved ? 'SUCCESS: Ready to merge' : ' Blocked until approval'}`,
                "",
                "### RETRY: Next Steps",
                approved ?
                  'This PR has been approved and is ready for merge (subject to other branch protection rules).' :
                  [
                    '1. Wait for the Claude AI Review Bot to analyze your PR',
                    '2. Address any REQUIRED recommendations if found',
                    '3. Once approved by Claude AI, this check will pass automatically',
                    '4. The PR will then be ready for merge'
                  ].join('\n'),
                "",
                "### INFO: About This Check",
                "This is an automated gate that ensures all PRs receive Claude AI review before merging. The check will update automatically when Claude AI provides approval.",
                "",
                "TIP: **Tip**: You can mention @claude in a comment to trigger a re-evaluation of the approval status.",
                "",
                "---",
                "*Claude AI Approval Gate - Automated Merge Protection*"
              ].join('\n');
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody
            });

            console.log(`NOTE: Posted ${triggerReason === '@claude mention in comment' ? 're-evaluation' : 'initial'} status comment`);

  # New job: @blazecommerce-claude-ai auto-approval logic
  blazecommerce-claude-ai-approval:
    needs: [check-trigger]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10

    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Evaluate Claude Review for Auto-Approval
        id: evaluate-review
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_GITHUB_TOKEN }}
          script: |
            // SECURITY FIX: Proper input sanitization to prevent script injection
            const prNumberRaw = '${{ needs.check-trigger.outputs.pr_number }}';
            const prNumber = parseInt(prNumberRaw, 10);

            if (!prNumber || isNaN(prNumber) || prNumber <= 0) {
              console.log('ERROR: Invalid PR number provided:', prNumberRaw);
              core.setOutput('should_approve', 'false');
              core.setOutput('reason', 'Invalid PR number');
              return;
            }

            console.log(`üöÄ BLAZECOMMERCE AUTO-APPROVAL: Evaluating Claude review for PR #${prNumber}`);

            try {
              // Check for official Claude App review comments
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                per_page: 100
              });

              console.log(`üìä TOTAL COMMENTS FOUND: ${comments.data.length}`);

              // ENHANCED: Strict Claude comment detection with working comment filtering
              const claudeAppComments = comments.data.filter(comment => {
                // SECURITY FIX: Enhanced authentication verification
                const isClaudeUser = comment.user.login === 'claude[bot]' ||
                                    comment.user.login === 'claude' ||
                                    (comment.user.login.includes('claude') && comment.user.type === 'Bot');

                // CRITICAL: Must have FINAL VERDICT section to be considered a complete review
                const hasFinalVerdict = comment.body && (
                  comment.body.includes('FINAL VERDICT') ||
                  comment.body.includes('### FINAL VERDICT')
                );

                // FILTER OUT: Working/intermediate comments that don't contain final verdict
                const isWorkingComment = comment.body && (
                  comment.body.includes('Claude is working') ||
                  comment.body.includes('Claude Code is working') ||
                  comment.body.includes('working‚Ä¶') ||
                  comment.body.includes('Review in Progress') ||
                  comment.body.includes('PR Review in Progress') ||
                  comment.body.includes('Analysis Progress') ||
                  comment.body.includes('Tasks:') && !hasFinalVerdict
                );

                // Only accept comments that are from Claude AND have final verdict AND are not working comments
                const isValidFinalReview = isClaudeUser && hasFinalVerdict && !isWorkingComment;

                if (isClaudeUser && !hasFinalVerdict) {
                  console.log(`‚ö†Ô∏è FILTERED OUT: Claude comment without FINAL VERDICT (likely working comment)`);
                }
                if (isWorkingComment) {
                  console.log(`‚ö†Ô∏è FILTERED OUT: Working/intermediate comment detected`);
                }
                if (isValidFinalReview) {
                  console.log(`üéØ FOUND VALID FINAL REVIEW: User=${comment.user.login}, HasFinalVerdict=true, NotWorking=true`);
                }

                return isValidFinalReview;
              });

              if (claudeAppComments.length === 0) {
                console.log('‚ùå AUTO-APPROVAL: No valid Claude final review found yet');
                console.log('   Waiting for Claude to complete review with FINAL VERDICT section');
                core.setOutput('should_approve', 'false');
                core.setOutput('reason', 'No complete Claude review with FINAL VERDICT found');
                return;
              }

              console.log(`‚úÖ AUTO-APPROVAL: Found ${claudeAppComments.length} Claude App comment(s)`);

              // Analyze Claude's feedback using standardized format from CLAUDE.md
              let hasRequiredIssues = false;
              let claudeReviewContent = '';
              let claudeApprovalStatus = 'unknown';

              for (const comment of claudeAppComments) {
                claudeReviewContent += comment.body + '\n\n';

                // Enhanced debugging - show full comment structure
                console.log('üîç AUTO-APPROVAL: SEARCHING FOR FINAL VERDICT SECTION...');
                console.log('üìÑ Comment ID:', comment.id);
                console.log('üìÑ Comment author:', comment.user.login);
                console.log('üìÑ Comment body length:', comment.body.length);
                console.log('üìÑ Comment contains "FINAL VERDICT":', comment.body.includes('FINAL VERDICT'));
                console.log('üìÑ Comment contains "Status":', comment.body.includes('Status'));
                console.log('üìÑ Comment contains "**Status**":', comment.body.includes('**Status**'));

                // Show relevant part of comment for debugging with more context
                const finalVerdictIndex = comment.body.indexOf('FINAL VERDICT');
                if (finalVerdictIndex !== -1) {
                  const relevantSection = comment.body.substring(finalVerdictIndex, finalVerdictIndex + 500);
                  console.log('üìÑ FINAL VERDICT SECTION (500 chars):', relevantSection);

                  // Show the exact status line for debugging
                  const statusMatch = relevantSection.match(/\*\*Status\*\*:.*$/m);
                  if (statusMatch) {
                    console.log('üìÑ EXACT STATUS LINE:', statusMatch[0]);
                  }
                } else {
                  // If no FINAL VERDICT section, show first 200 chars for debugging
                  console.log('üìÑ COMMENT START (200 chars):', comment.body.substring(0, 200));
                }

                // COMPREHENSIVE PATTERN MATCHING FOR CLAUDE'S APPROVAL FORMAT
                console.log('üîç AUTO-APPROVAL: Starting comprehensive pattern matching...');
                let finalVerdictMatch = null;
                let detectionMethod = 'none';

                // Pattern 1: Bracketed format [APPROVED] - Original expected format
                console.log('üîç AUTO-APPROVAL: Testing Pattern 1: Bracketed format [APPROVED]');
                finalVerdictMatch = comment.body.match(/### FINAL VERDICT[\s\S]*?\*\*Status\*\*:\s*\[([^\]]+)\]/i);
                if (finalVerdictMatch) {
                  detectionMethod = 'bracketed';
                  console.log('‚úÖ AUTO-APPROVAL: Pattern 1 MATCHED:', finalVerdictMatch[1]);
                } else {
                  console.log('‚ùå AUTO-APPROVAL: Pattern 1 NO MATCH');
                }

                // Pattern 2: Claude's actual format - **Status**: APPROVED followed by newline and **
                if (!finalVerdictMatch) {
                  console.log('üîç AUTO-APPROVAL: Testing Pattern 2: Claude actual format (**Status**: APPROVED\\n**)');
                  finalVerdictMatch = comment.body.match(/### FINAL VERDICT[\s\S]*?\*\*Status\*\*:\s*([A-Z\s]+?)\s*\n\*\*/i);
                  if (finalVerdictMatch) {
                    detectionMethod = 'claude-actual-format';
                    console.log('‚úÖ AUTO-APPROVAL: Pattern 2 MATCHED:', finalVerdictMatch[1]);
                  } else {
                    console.log('‚ùå AUTO-APPROVAL: Pattern 2 NO MATCH');
                  }
                }

                // Pattern 3: Simple status detection - **Status**: APPROVED (any ending)
                if (!finalVerdictMatch) {
                  console.log('üîç AUTO-APPROVAL: Testing Pattern 3: Simple status detection');
                  finalVerdictMatch = comment.body.match(/\*\*Status\*\*:\s*([A-Z\s]+?)(?:\s*\n|\s*\*\*|$)/i);
                  if (finalVerdictMatch) {
                    detectionMethod = 'simple-status';
                    console.log('‚úÖ AUTO-APPROVAL: Pattern 3 MATCHED:', finalVerdictMatch[1]);
                  } else {
                    console.log('‚ùå AUTO-APPROVAL: Pattern 3 NO MATCH');
                  }
                }

                // Pattern 4: Broad detection - any Status: APPROVED pattern
                if (!finalVerdictMatch) {
                  console.log('üîç AUTO-APPROVAL: Testing Pattern 4: Broad status detection');
                  finalVerdictMatch = comment.body.match(/Status\*?\*?:\s*([A-Z\s]+?)(?:\s*\n|\s*\*|$)/i);
                  if (finalVerdictMatch) {
                    detectionMethod = 'broad-detection';
                    console.log('‚úÖ AUTO-APPROVAL: Pattern 4 MATCHED:', finalVerdictMatch[1]);
                  } else {
                    console.log('‚ùå AUTO-APPROVAL: Pattern 4 NO MATCH');
                  }
                }

                // Pattern 5: Case-insensitive fallback
                if (!finalVerdictMatch) {
                  console.log('üîç AUTO-APPROVAL: Testing Pattern 5: Case-insensitive fallback');
                  if (comment.body.toLowerCase().includes('status') && comment.body.toLowerCase().includes('approved')) {
                    // Extract the word after "status"
                    const caseInsensitiveMatch = comment.body.match(/status[^:]*:\s*([a-z\s]+?)(?:\s*\n|\s*\*|$)/i);
                    if (caseInsensitiveMatch && caseInsensitiveMatch[1].toLowerCase().includes('approved')) {
                      finalVerdictMatch = [null, caseInsensitiveMatch[1]];
                      detectionMethod = 'case-insensitive-fallback';
                      console.log('‚úÖ AUTO-APPROVAL: Pattern 5 MATCHED:', finalVerdictMatch[1]);
                    } else {
                      console.log('‚ùå AUTO-APPROVAL: Pattern 5 NO MATCH');
                    }
                  } else {
                    console.log('‚ùå AUTO-APPROVAL: Pattern 5 NO MATCH - no status/approved keywords');
                  }
                }

                // ENHANCED STATUS PROCESSING WITH COMPREHENSIVE LOGGING
                if (finalVerdictMatch) {
                  const rawStatus = finalVerdictMatch[1];
                  const status = rawStatus.trim();
                  console.log(`üéØ FOUND FINAL VERDICT STATUS!`);
                  console.log(`   Raw status: "${rawStatus}"`);
                  console.log(`   Trimmed status: "${status}"`);
                  console.log(`   Detection method: ${detectionMethod}`);
                  console.log(`   Status length: ${status.length}`);
                  console.log(`   Status includes APPROVED: ${status.includes('APPROVED')}`);
                  console.log(`   Status includes CONDITIONAL: ${status.includes('CONDITIONAL')}`);
                  console.log(`   Status includes BLOCKED: ${status.includes('BLOCKED')}`);

                  // Enhanced status classification with case-insensitive matching
                  const statusUpper = status.toUpperCase();

                  if (statusUpper === 'APPROVED' || (statusUpper.includes('APPROVED') && !statusUpper.includes('CONDITIONAL'))) {
                    claudeApprovalStatus = 'approved';
                    console.log('‚úÖ CLASSIFICATION: Claude APPROVED the PR');
                  } else if (statusUpper === 'BLOCKED' || statusUpper.includes('BLOCKED')) {
                    claudeApprovalStatus = 'blocked';
                    hasRequiredIssues = true;
                    console.log('‚ùå CLASSIFICATION: Claude BLOCKED the PR');
                  } else if (statusUpper === 'CONDITIONAL APPROVAL' || statusUpper.includes('CONDITIONAL')) {
                    claudeApprovalStatus = 'conditional';
                    console.log('‚úÖ CLASSIFICATION: Claude CONDITIONALLY APPROVED the PR');
                  } else {
                    claudeApprovalStatus = 'unknown';
                    console.log(`‚ö†Ô∏è CLASSIFICATION: Unknown status: "${status}"`);
                    console.log(`   Will attempt fallback approval logic based on content analysis`);
                  }
                } else {
                  console.log('‚ùå NO FINAL VERDICT STATUS FOUND in comment');
                  console.log('   Comment preview:', comment.body.substring(0, 500) + '...');
                  console.log('   Attempting content-based analysis as fallback...');

                  // ENHANCED FALLBACK: Strict content analysis for FINAL VERDICT only
                  if (comment.body.includes('FINAL VERDICT') || comment.body.includes('### FINAL VERDICT')) {
                    const commentLower = comment.body.toLowerCase();

                    // PRIORITY 1: Check for explicit BLOCKED status first
                    if (commentLower.includes('blocked') || commentLower.includes('not ready') ||
                        commentLower.includes('rejected') || commentLower.includes('status: blocked') ||
                        commentLower.includes('status**: blocked')) {
                      console.log('‚ùå FALLBACK: Found BLOCKED indicators in FINAL VERDICT');
                      claudeApprovalStatus = 'blocked';
                      hasRequiredIssues = true;
                    }
                    // PRIORITY 2: Only check for approved if not already blocked
                    else if (commentLower.includes('approved') && !commentLower.includes('not approved')) {
                      console.log('‚úÖ FALLBACK: Found "approved" in FINAL VERDICT (no blocking indicators)');
                      claudeApprovalStatus = 'approved';
                    } else {
                      console.log('‚ö†Ô∏è FALLBACK: Unclear status in FINAL VERDICT - defaulting to unknown');
                      claudeApprovalStatus = 'unknown';
                      hasRequiredIssues = true;
                    } else {
                      console.log('‚ö†Ô∏è FALLBACK: No clear approval/rejection indicators in FINAL VERDICT');
                      claudeApprovalStatus = 'unknown';
                    }
                  } else {
                    console.log('‚ö†Ô∏è SKIPPING: Comment does not contain FINAL VERDICT - ignoring for approval');
                    claudeApprovalStatus = 'unknown';
                  }
                }

                // Also check for Critical Issues section content
                const criticalIssuesMatch = comment.body.match(/\*\*CRITICAL ISSUES\*\*([\s\S]*?)(?=\*\*STRENGTHS\*\*|\*\*AREAS FOR IMPROVEMENT\*\*|\*\*PERFORMANCE CONSIDERATIONS\*\*|\*\*SECURITY ASSESSMENT\*\*|###|$)/i);
                if (criticalIssuesMatch) {
                  const criticalContent = criticalIssuesMatch[1].trim();
                  // Check if there's actual content (not just empty lines or dashes)
                  if (criticalContent && criticalContent.length > 10 && !criticalContent.match(/^[\s\-_]*$/)) {
                    hasRequiredIssues = true;
                    console.log('Found content in Critical Issues section');
                  }
                }

                // STRICT: Only use legacy patterns if comment contains FINAL VERDICT
                if (claudeApprovalStatus === 'unknown' && (comment.body.includes('FINAL VERDICT') || comment.body.includes('### FINAL VERDICT'))) {
                  if (comment.body.match(/CRITICAL:\s*REQUIRED|REQUIRED.*issues?|must\s+be\s+fixed|critical\s+bugs?/i)) {
                    hasRequiredIssues = true;
                    claudeApprovalStatus = 'blocked';
                    console.log('Found REQUIRED issues using legacy pattern matching in FINAL VERDICT');
                  } else if (comment.body.match(/no\s+critical\s+issues|ready\s+to\s+merge|looks\s+good/i)) {
                    claudeApprovalStatus = 'approved';
                    console.log('Found approval indicators using legacy pattern matching in FINAL VERDICT');
                  }
                }

                // Additional validation: Check for implementation verification language
                if (claudeApprovalStatus === 'approved' && comment.body.match(/previous.*changes.*not.*implemented|required.*changes.*missing|still.*need.*to.*address/i)) {
                  claudeApprovalStatus = 'blocked';
                  hasRequiredIssues = true;
                  console.log('Detected unimplemented previous changes - overriding to blocked status');
                }
              }

              // Check if @blazecommerce-claude-ai has already approved
              const reviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100
              });

              const existingApproval = reviews.data.find(review =>
                review.user.login === 'blazecommerce-claude-ai' && review.state === 'APPROVED'
              );

              if (existingApproval) {
                console.log('INFO: @blazecommerce-claude-ai has already approved this PR');
                core.setOutput('should_approve', 'false');
                core.setOutput('reason', 'Already approved');
                return;
              }

              // ENHANCED DECISION LOGIC WITH COMPREHENSIVE LOGGING
              console.log('üéØ FINAL DECISION LOGIC ANALYSIS:');
              console.log('=' .repeat(60));
              console.log(`üìä APPROVAL STATUS: "${claudeApprovalStatus}"`);
              console.log(`üö® HAS REQUIRED ISSUES: ${hasRequiredIssues}`);
              console.log(`üìù REVIEW CONTENT LENGTH: ${claudeReviewContent.length} characters`);
              console.log(`üîç TOTAL CLAUDE COMMENTS ANALYZED: ${claudeAppComments.length}`);
              console.log('=' .repeat(60));

              // Decision tree with detailed logging
              let finalDecision = false;
              let decisionReason = '';

              if (claudeApprovalStatus === 'approved' && !hasRequiredIssues) {
                finalDecision = true;
                decisionReason = 'Claude approved with APPROVED status and no critical issues';
                console.log('‚úÖ DECISION: AUTO-APPROVE - Claude explicitly approved with no issues');
              } else if (claudeApprovalStatus === 'conditional' && !hasRequiredIssues) {
                finalDecision = true;
                decisionReason = 'Claude conditionally approved with CONDITIONAL APPROVAL and no critical issues';
                console.log('‚úÖ DECISION: AUTO-APPROVE - Claude conditionally approved with no issues');
              } else if (claudeApprovalStatus === 'unknown' && !hasRequiredIssues) {
                finalDecision = true;
                decisionReason = 'No explicit status found but no critical issues detected in Claude review';
                console.log('‚úÖ DECISION: AUTO-APPROVE - Fallback approval (no status found but no issues)');
              } else if (claudeApprovalStatus === 'blocked' || hasRequiredIssues) {
                finalDecision = false;
                decisionReason = 'Claude blocked with BLOCKED status or critical issues found';
                console.log('‚ùå DECISION: BLOCK - Claude explicitly blocked or critical issues found');
              } else {
                finalDecision = false;
                decisionReason = `Uncertain approval status: ${claudeApprovalStatus}, hasIssues: ${hasRequiredIssues}`;
                console.log('‚ùå DECISION: BLOCK - Uncertain status, defaulting to safe (no approval)');
              }

              console.log('üéØ FINAL DECISION SUMMARY:');
              console.log(`   SHOULD APPROVE: ${finalDecision}`);
              console.log(`   REASON: ${decisionReason}`);
              console.log('=' .repeat(60));

              core.setOutput('should_approve', finalDecision.toString());
              core.setOutput('reason', decisionReason);
              if (finalDecision) {
                core.setOutput('claude_review_summary', claudeReviewContent.substring(0, 1000) + '...');
              } else {
                core.setOutput('claude_review_summary', 'Review blocked due to critical issues');
              }

              // COMPREHENSIVE DEBUG: Show final decision with all factors
              console.log(`üéØ FINAL DECISION SUMMARY:`);
              console.log(`   should_approve = ${finalDecision}`);
              console.log(`   claudeApprovalStatus = "${claudeApprovalStatus}"`);
              console.log(`   hasRequiredIssues = ${hasRequiredIssues}`);
              console.log(`   decisionReason = "${decisionReason}"`);
              console.log(`   Total comments analyzed = ${claudeAppComments.length}`);
              console.log('üîí SECURITY: Auto-approval decision based on strict FINAL VERDICT parsing only');

            } catch (error) {
              console.error(`ERROR: Failed to evaluate Claude review: ${error.message}`);
              core.setOutput('should_approve', 'false');
              core.setOutput('reason', `Error: ${error.message}`);
            }

      - name: Auto-Approve PR as @blazecommerce-claude-ai
        if: steps.evaluate-review.outputs.should_approve == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ needs.check-trigger.outputs.pr_number }}';
            const shouldApprove = '${{ steps.evaluate-review.outputs.should_approve }}';
            const reason = '${{ steps.evaluate-review.outputs.reason }}';

            console.log('üöÄ AUTO-APPROVAL STEP EXECUTING!');
            console.log('=' .repeat(80));
            console.log(`üìã PR NUMBER: ${prNumber}`);
            console.log(`‚úÖ SHOULD APPROVE: ${shouldApprove}`);
            console.log(`üìù REASON: ${reason}`);
            console.log(`üîë TOKEN: ${process.env.GITHUB_TOKEN ? 'Present' : 'Missing'}`);
            console.log(`üì° API ENDPOINT: POST /repos/${context.repo.owner}/${context.repo.repo}/pulls/${prNumber}/reviews`);
            console.log(`üéØ EVENT TYPE: APPROVE`);
            console.log('=' .repeat(80));
            console.log('üöÄ EXECUTING APPROVAL API CALL...');

            try {
              const approvalResponse = await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                event: 'APPROVE',
                body: [
                  "## BlazeCommerce Claude AI Review - Auto-Approved",
                  "",
                  "**Automated approval by @blazecommerce-claude-ai**",
                  "",
                  "### Review Summary",
                  "- Official Claude GitHub App completed comprehensive review",
                  "- No CRITICAL: REQUIRED issues found",
                  "- Code meets BlazeCommerce quality standards",
                  "- All security and performance checks passed",
                  "",
                  "### Claude AI Analysis",
                  "The official Claude App has reviewed this PR and found no blocking issues. The code follows WordPress plugin best practices and BlazeCommerce development standards.",
                  "",
                  "### Next Steps",
                  "This PR is now approved and ready for merge (subject to other branch protection rules and checks).",
                  "",
                  "---",
                  "*Automated approval by BlazeCommerce Claude AI Review System*",
                  "*Based on official Claude GitHub App analysis*"
                ].join('\n')
              });

              console.log('‚úÖ SUCCESS: Approval API call completed!');
              console.log(`üìã Review ID: ${approvalResponse.data.id}`);
              console.log(`üìã Review State: ${approvalResponse.data.state}`);
              console.log(`üìã Review URL: ${approvalResponse.data.html_url}`);
              console.log('üéâ PR auto-approved by @blazecommerce-claude-ai');

            } catch (error) {
              console.error(`ERROR: Failed to auto-approve PR: ${error.message}`);

              // Post error comment
              try {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: [
                    "## BlazeCommerce Claude AI Review - Approval Error",
                    "",
                    "**Error**: Failed to auto-approve this PR.",
                    "",
                    `**Details**: ${error.message}`,
                    "",
                    "**Action Required**: Manual approval needed.",
                    "",
                    "*Please contact repository administrators if this issue persists.*"
                  ].join('\n')
                });
              } catch (commentError) {
                console.error(`ERROR: Failed to post error comment: ${commentError.message}`);
              }
            }

      - name: Post Blocking Issues Comment
        if: steps.evaluate-review.outputs.should_approve == 'false' && steps.evaluate-review.outputs.reason == 'REQUIRED issues found in Claude review'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ needs.check-trigger.outputs.pr_number }}';

            console.log(`INFO: Posting blocking issues comment for PR #${prNumber}`);

            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: [
                  "## BlazeCommerce Claude AI Review - Approval Blocked",
                  "",
                  "**Status**: Cannot auto-approve due to REQUIRED issues",
                  "",
                  "### Action Required",
                  "The official Claude GitHub App has identified **CRITICAL: REQUIRED** issues that must be addressed before this PR can be approved.",
                  "",
                  "### Next Steps",
                  "1. Review Claude's feedback above for specific REQUIRED issues",
                  "2. Address all CRITICAL: REQUIRED items",
                  "3. Push your changes to trigger a new review",
                  "4. @blazecommerce-claude-ai will automatically approve once all REQUIRED issues are resolved",
                  "",
                  "### Re-evaluation",
                  "This PR will be automatically re-evaluated when:",
                  "- New commits are pushed",
                  "- Claude provides an updated review",
                  "- All REQUIRED issues are addressed",
                  "",
                  "---",
                  "*Automated blocking by BlazeCommerce Claude AI Review System*",
                  "*Based on official Claude GitHub App analysis*"
                ].join('\n')
              });

              console.log('SUCCESS: Posted blocking issues comment');

            } catch (error) {
              console.error(`ERROR: Failed to post blocking comment: ${error.message}`);
            }
