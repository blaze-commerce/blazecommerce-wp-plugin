name: "Priority 3: Auto Version Bump"

on:
  push:
    branches:
      - main
      - develop
      - 'feature/**'
      - 'release/**'

# Priority 3: Post-merge workflow - runs after PR workflows complete
concurrency:
  group: priority-3-auto-version-${{ github.repository }}
  cancel-in-progress: false  # Don't cancel to ensure version consistency

jobs:
  version-bump:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ vars.AUTO_VERSION_TIMEOUT || 20 }}
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, 'chore(release)') && !contains(github.event.head_commit.message, '[no version]')"
    permissions:
      # Minimum required permissions for auto-version workflow
      contents: write         # Required: Update version files and create commits
      pull-requests: read     # Required: Read PR information for version analysis
      actions: read           # Required: Read workflow run information
      # Security: All other permissions explicitly denied (no issues, packages, etc.)

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.BC_GITHUB_TOKEN || github.token }}
        fetch-depth: 0

    - name: Check if version bump is needed
      id: check_files
      run: |
        echo "üîç Checking if version bump is needed based on changed files..."

        # Get list of changed files in this push with optimized git operations
        if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
          # First push to branch - check all files in the commit
          echo "üîç First push detected, analyzing all files in commit"
          if ! CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRT HEAD~1 2>/dev/null); then
            echo "‚ö†Ô∏è  Could not get diff, falling back to listing all tracked files"
            CHANGED_FILES=$(git ls-files --cached --exclude-standard)
          fi
        else
          # Regular push - check files changed since previous commit with optimized filters
          echo "üîç Regular push detected, analyzing changed files"
          # Use --diff-filter to only include Added, Copied, Modified, Renamed, Type-changed files
          # This excludes deleted files which don't need version bump consideration
          if ! CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRT "${{ github.event.before }}..${{ github.event.after }}" 2>/dev/null); then
            echo "‚ùå Failed to get changed files between commits"
            echo "   Before: ${{ github.event.before }}"
            echo "   After: ${{ github.event.after }}"
            echo "   Attempting alternative method..."
            # Fallback: try getting files from the current commit only
            if ! CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRT HEAD~1 2>/dev/null); then
              echo "‚ùå All git diff methods failed"
              exit 1
            fi
          fi
        fi

        # Validate that we have files to analyze
        if [ -z "$CHANGED_FILES" ]; then
          echo "‚ö†Ô∏è  No changed files detected, skipping version bump"
          echo "should_bump_version=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "üìÅ Changed files:"
        echo "$CHANGED_FILES"
        echo ""

        # Use extracted file detection script for better maintainability and testability
        echo "üîç Analyzing changed files using dedicated detection script..."

        # Validate that required scripts exist
        if [ ! -f "scripts/check-file-changes.sh" ]; then
          echo "‚ùå Required script 'scripts/check-file-changes.sh' not found"
          echo "   This script is required for file change analysis"
          exit 1
        fi

        # Determine if we should use performance mode for large changesets
        FILE_COUNT=$(echo "$CHANGED_FILES" | wc -l)
        PERFORMANCE_ARGS=""
        if [ "$FILE_COUNT" -gt 50 ]; then
          echo "üìä Large changeset detected ($FILE_COUNT files) - enabling performance mode"
          PERFORMANCE_ARGS="--performance-mode"
        fi

        # Run file detection script and capture result
        SHOULD_BUMP="false"
        if echo "$CHANGED_FILES" | bash scripts/check-file-changes.sh /dev/stdin $PERFORMANCE_ARGS; then
          SHOULD_BUMP="true"
          echo "üöÄ File analysis complete - version bump needed"
        else
          echo "‚è≠Ô∏è  File analysis complete - version bump skipped"
        fi

        echo ""
        if [ "$SHOULD_BUMP" = "true" ]; then
          echo "üöÄ Version bump needed - non-ignored files were changed"
        else
          echo "‚è≠Ô∏è  Version bump skipped - only ignored files were changed"
        fi

        echo "should_bump_version=$SHOULD_BUMP" >> $GITHUB_OUTPUT

    - name: Setup Node.js
      if: steps.check_files.outputs.should_bump_version == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      if: steps.check_files.outputs.should_bump_version == 'true'
      run: npm install

    - name: Configure Git
      if: steps.check_files.outputs.should_bump_version == 'true'
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        echo "‚úÖ Git configured for automated commits"

    - name: Run version system tests
      if: steps.check_files.outputs.should_bump_version == 'true'
      run: |
        echo "üß™ Running version system tests..."

        # Check if test script exists before running
        if npm run test:version-system --silent 2>/dev/null; then
          echo "‚úÖ Version system tests passed"
        elif [ $? -eq 127 ] || ! npm run | grep -q "test:version-system"; then
          echo "‚ö†Ô∏è  test:version-system script not found, running fallback validation..."

          # Fallback: Basic validation of core functions
          node -e "
            try {
              const semver = require('./scripts/semver-utils');
              console.log('‚úÖ semver-utils module loads successfully');

              // Test basic functions exist
              if (typeof semver.incrementVersion !== 'function') throw new Error('incrementVersion function missing');
              if (typeof semver.findNextAvailableVersion !== 'function') throw new Error('findNextAvailableVersion function missing');
              if (typeof semver.tagExists !== 'function') throw new Error('tagExists function missing');

              console.log('‚úÖ Core functions are available');
              console.log('‚úÖ Fallback validation passed');
            } catch (error) {
              console.error('‚ùå Fallback validation failed:', error.message);
              process.exit(1);
            }
          "
        else
          echo "‚ùå Version system tests failed. Aborting version bump."
          echo "   Exit code: $?"
          echo "   Please check test implementation and dependencies"
          exit 1
        fi

    - name: Validate current version system
      if: steps.check_files.outputs.should_bump_version == 'true'
      run: |
        echo "üîç Validating current version system..."

        # Validate that required script exists
        if [ ! -f "scripts/validate-version.js" ]; then
          echo "‚ùå Required script 'scripts/validate-version.js' not found"
          echo "   This script is required for version validation"
          exit 1
        fi

        # Skip conflict checking since we handle version conflicts in the workflow
        if ! node scripts/validate-version.js --verbose --no-conflicts; then
          echo "‚ùå Version validation failed. Aborting version bump."
          echo "   Check the validation output above for specific issues"
          exit 1
        fi

        echo "‚úÖ Version validation passed"

    - name: Determine prerelease type based on branch
      if: steps.check_files.outputs.should_bump_version == 'true'
      id: prerelease_type
      run: |
        echo "üåø Determining prerelease type based on branch..."
        BRANCH_NAME="${GITHUB_REF#refs/heads/}"
        echo "üìã Current branch: $BRANCH_NAME"

        # Branch-based prerelease strategy
        if [[ "$BRANCH_NAME" == feature/* ]]; then
          echo "PRERELEASE=alpha" >> $GITHUB_OUTPUT
          echo "üî¨ Feature branch detected ‚Üí alpha prerelease"
        elif [[ "$BRANCH_NAME" == "develop" ]]; then
          echo "PRERELEASE=beta" >> $GITHUB_OUTPUT
          echo "üß™ Develop branch detected ‚Üí beta prerelease"
        elif [[ "$BRANCH_NAME" == release/* ]]; then
          echo "PRERELEASE=rc" >> $GITHUB_OUTPUT
          echo "üöÄ Release branch detected ‚Üí release candidate"
        elif [[ "$BRANCH_NAME" == "main" ]] || [[ "$BRANCH_NAME" == "master" ]]; then
          echo "PRERELEASE=" >> $GITHUB_OUTPUT
          echo "üì¶ Main branch detected ‚Üí stable release"
        else
          echo "PRERELEASE=" >> $GITHUB_OUTPUT
          echo "üîß Other branch detected ‚Üí stable release"
        fi

    - name: Validate version consistency
      id: version_validation
      run: |
        echo "üîç Validating version consistency between package.json and git tags..."
        echo "   This step prevents unexpected version bumps by detecting mismatches"
        echo "   between the current package.json version and the latest git tag."

        # Extract current version from package.json
        # This is the source of truth for the current version state
        PACKAGE_VERSION=$(node -p "require('./package.json').version")

        # Get the latest version tag using optimized git command
        # Using --sort=-version:refname for more reliable version ordering (Claude's recommendation)
        # Performance optimization: Limit tag listing to prevent expensive operations (Claude's recommendation)
        # Fix: Use head -n10 instead of --count=10 flag which doesn't exist (Claude's recommendation)
        # Fallback to git describe if no tags exist to maintain compatibility
        LATEST_VERSION_TAG=$(git tag --list 'v*' --sort=-version:refname | head -n10 | head -n1 2>/dev/null || echo "")
        if [ -z "$LATEST_VERSION_TAG" ]; then
          # Fallback to git describe for repositories with non-standard tag formats
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
        else
          LAST_TAG="$LATEST_VERSION_TAG"
        fi

        EXPECTED_TAG="v$PACKAGE_VERSION"

        echo "üì¶ Package version: $PACKAGE_VERSION"
        echo "üè∑Ô∏è  Last git tag: $LAST_TAG"
        echo "üéØ Expected tag: $EXPECTED_TAG"
        echo "üîß Tag retrieval method: $([ -n "$LATEST_VERSION_TAG" ] && echo "optimized version sort" || echo "git describe fallback")"

        # Validate semver format with simplified and tightened regex to prevent edge cases
        # Claude's recommendation: Simplify regex to prevent cases like 1.0.0-- or 1.0.0++
        if ! echo "$PACKAGE_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$'; then
          echo "‚ùå Error: Package version '$PACKAGE_VERSION' is not a valid semver format"
          echo "   Expected format: MAJOR.MINOR.PATCH[-prerelease][+metadata]"
          echo "   Examples: 1.0.0, 1.0.0-alpha.1, 1.0.0+build.123"
          echo "   Note: Prerelease and metadata sections must contain valid characters"
          exit 1
        fi

        # Enhanced version mismatch detection with explicit "none" handling
        if [ "$LAST_TAG" = "none" ] || [ "$LAST_TAG" != "$EXPECTED_TAG" ]; then
          if [ "$LAST_TAG" = "none" ]; then
            echo "‚ö†Ô∏è  No git tags found - this is the first versioned release"
            echo "   Package.json version: $PACKAGE_VERSION"
            echo "   Recommendation: Create initial tag after this release"
          else
            echo "‚ö†Ô∏è  Version mismatch detected!"
            echo "   Package.json version: $PACKAGE_VERSION"
            echo "   Last git tag: $LAST_TAG"
            echo "   Expected tag: $EXPECTED_TAG"
            echo "   This may cause unexpected version bumps due to analyzing too many commits"
          fi
          echo "VERSION_MISMATCH=true" >> $GITHUB_OUTPUT
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "LAST_TAG=$LAST_TAG" >> $GITHUB_OUTPUT
        else
          echo "‚úÖ Version consistency validated"
          echo "VERSION_MISMATCH=false" >> $GITHUB_OUTPUT
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "LAST_TAG=$LAST_TAG" >> $GITHUB_OUTPUT
        fi

    - name: Determine version bump type
      if: steps.check_files.outputs.should_bump_version == 'true'
      id: bump_type
      run: |
        echo "üîç Analyzing commits for version bump type..."
        echo "   This step determines whether to perform a MAJOR, MINOR, or PATCH version bump"
        echo "   based on conventional commit patterns in the commit history."
        echo ""
        echo "üìã Commit Analysis Strategy:"
        echo "   ‚Ä¢ Normal operation: Analyze commits since last matching git tag"
        echo "   ‚Ä¢ Version mismatch: Use limited analysis to avoid historical features"
        echo "   ‚Ä¢ No tags found: Analyze recent commits with fallback limits"
        echo ""

        # Check for version mismatch and adjust analysis scope accordingly
        # This prevents analyzing hundreds of historical commits when git tags are outdated
        VERSION_MISMATCH="${{ steps.version_validation.outputs.VERSION_MISMATCH }}"
        PACKAGE_VERSION="${{ steps.version_validation.outputs.PACKAGE_VERSION }}"
        LAST_TAG="${{ steps.version_validation.outputs.LAST_TAG }}"

        # Configurable commit analysis limits (Claude's recommendation to avoid magic numbers)
        # These can be overridden via environment variables for different repository needs
        LIMITED_COMMIT_LIMIT=${LIMITED_COMMIT_LIMIT:-25}  # For version mismatch scenarios
        FALLBACK_COMMIT_LIMIT=${FALLBACK_COMMIT_LIMIT:-50}  # For normal analysis fallback

        echo "üîß Configuration: Limited analysis limit = $LIMITED_COMMIT_LIMIT commits"
        echo "üîß Configuration: Fallback analysis limit = $FALLBACK_COMMIT_LIMIT commits"

        if [ "$VERSION_MISMATCH" = "true" ]; then
          echo "‚ö†Ô∏è  Version mismatch detected - using limited commit analysis"
          echo "üìã Analyzing only recent commits to avoid historical feature detection"
          # When there's a version mismatch, only analyze recent commits
          # to avoid picking up historical features that should not trigger version bumps
          COMMITS=$(git log --oneline --no-merges --format="%s" -${LIMITED_COMMIT_LIMIT})
          echo "üîß Limited analysis: analyzing last $LIMITED_COMMIT_LIMIT commits only"

          # Validate commits were found in limited analysis
          if [ -z "$COMMITS" ]; then
            echo "‚ùå Error: No commits found in limited analysis"
            echo "üîÑ Attempting fallback analysis..."
            COMMITS=$(git log --oneline --no-merges --format="%s" -${FALLBACK_COMMIT_LIMIT})
            if [ -z "$COMMITS" ]; then
              echo "‚ùå Error: No commits found even in fallback analysis"
              echo "BUMP_TYPE=none" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
        else
          # Normal analysis: get commits since last version tag
          if [ "$LAST_TAG" != "none" ] && [ -n "$LAST_TAG" ]; then
            echo "üìã Analyzing commits since tag: $LAST_TAG"
            COMMITS=$(git log --oneline --no-merges --format="%s" ${LAST_TAG}..HEAD)

            # Validate commits were found in normal analysis
            if [ -z "$COMMITS" ]; then
              echo "‚ÑπÔ∏è  No commits found since last tag - using fallback analysis"
              COMMITS=$(git log --oneline --no-merges --format="%s" -${FALLBACK_COMMIT_LIMIT})

              # Validate fallback analysis results
              if [ -z "$COMMITS" ]; then
                echo "‚ùå Error: No commits found even in fallback analysis"
                echo "BUMP_TYPE=none" >> $GITHUB_OUTPUT
                exit 0
              fi
            fi
          else
            echo "üìã No previous tags found, analyzing last $FALLBACK_COMMIT_LIMIT commits"
            COMMITS=$(git log --oneline --no-merges --format="%s" -${FALLBACK_COMMIT_LIMIT})

            # Validate commits were found when no tags exist
            if [ -z "$COMMITS" ]; then
              echo "‚ùå Error: No commits found even when analyzing last $FALLBACK_COMMIT_LIMIT commits"
              echo "   This suggests an empty repository or git configuration issue"
              echo "BUMP_TYPE=none" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # Final validation for normal analysis
          if [ -z "$COMMITS" ]; then
            echo "‚ùå Error: No commits found in normal analysis"
            echo "BUMP_TYPE=none" >> $GITHUB_OUTPUT
            exit 0
          fi
        fi

        # Final safety check
        if [ -z "$COMMITS" ]; then
          echo "‚ÑπÔ∏è  No commits found to analyze after all attempts"
          echo "BUMP_TYPE=none" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Display commit analysis summary for debugging
        COMMIT_COUNT=$(echo "$COMMITS" | wc -l)
        echo "üìä Commits to analyze (total: $COMMIT_COUNT):"
        echo "$COMMITS" | head -10
        if [ $COMMIT_COUNT -gt 10 ]; then
          echo "... and $(( $COMMIT_COUNT - 10 )) more"
        fi
        echo ""

        # Validate commit count is reasonable (edge case handling)
        if [ $COMMIT_COUNT -gt 1000 ]; then
          echo "‚ö†Ô∏è  Warning: Analyzing $COMMIT_COUNT commits - this may indicate a configuration issue"
          echo "   Consider checking your git tag synchronization or commit analysis limits"
        fi

        # Enhanced conventional commit detection with comprehensive pattern matching
        # This follows the Conventional Commits specification (https://conventionalcommits.org/)
        echo "üîç Scanning commits for conventional commit patterns..."
        HAS_BREAKING=false
        HAS_FEATURE=false
        HAS_FIX=false
        HAS_PERF=false

        while IFS= read -r commit; do
          # Skip empty lines
          [ -z "$commit" ] && continue

          # Check for breaking changes (multiple patterns)
          if echo "$commit" | grep -qE "^(feat|fix|docs|style|refactor|perf|test|chore|build|ci)(\(.+\))?!:" || \
             echo "$commit" | grep -qE "BREAKING CHANGE" || \
             echo "$commit" | grep -qE "^(feat|fix)!(\(.+\))?:"; then
            HAS_BREAKING=true
            echo "üí• Breaking change detected: $commit"
          # Check for features
          elif echo "$commit" | grep -qE "^feat(\(.+\))?:"; then
            HAS_FEATURE=true
            echo "‚ú® Feature detected: $commit"
          # Check for fixes and performance improvements
          elif echo "$commit" | grep -qE "^(fix|perf)(\(.+\))?:"; then
            if echo "$commit" | grep -qE "^fix(\(.+\))?:"; then
              HAS_FIX=true
              echo "üêõ Fix detected: $commit"
            else
              HAS_PERF=true
              echo "‚ö° Performance improvement detected: $commit"
            fi
          fi
        done <<< "$COMMITS"

        # Determine bump type based on priority (BREAKING > FEATURE > FIX/PERF > NONE)
        echo "üìã Commit pattern analysis results:"
        echo "   Breaking changes: $HAS_BREAKING"
        echo "   New features: $HAS_FEATURE"
        echo "   Bug fixes: $HAS_FIX"
        echo "   Performance improvements: $HAS_PERF"
        echo ""

        if [ "$HAS_BREAKING" = true ]; then
          echo "BUMP_TYPE=major" >> $GITHUB_OUTPUT
          echo "üöÄ Result: MAJOR version bump (breaking changes detected)"
          echo "   ‚ö†Ô∏è  This will increment the major version and reset minor/patch to 0"
        elif [ "$HAS_FEATURE" = true ]; then
          echo "BUMP_TYPE=minor" >> $GITHUB_OUTPUT
          echo "üöÄ Result: MINOR version bump (new features detected)"
          echo "   ‚ú® This will increment the minor version and reset patch to 0"
        elif [ "$HAS_FIX" = true ] || [ "$HAS_PERF" = true ]; then
          echo "BUMP_TYPE=patch" >> $GITHUB_OUTPUT
          echo "üöÄ Result: PATCH version bump (fixes/improvements detected)"
          echo "   üêõ This will increment only the patch version"
        else
          echo "BUMP_TYPE=none" >> $GITHUB_OUTPUT
          echo "‚ÑπÔ∏è  Result: No version bump (no conventional commits found)"
          echo "   üìù Consider using conventional commit format: feat:, fix:, etc."
        fi

    - name: Enhanced Commit Analysis (Optional)
      if: steps.check_files.outputs.should_bump_version == 'true'
      id: enhanced_analysis
      continue-on-error: true
      run: |
        echo "üöÄ Running enhanced commit analysis using extracted scripts..."

        # Check if enhanced scripts exist
        if [ ! -f ".github/scripts/commit-parser.js" ] || [ ! -f ".github/scripts/version-analyzer.js" ]; then
          echo "‚ö†Ô∏è Enhanced analysis scripts not found, skipping enhanced analysis"
          echo "üìã Will use standard version calculation instead"
          exit 0
        fi

        # Get current version from multiple sources for validation
        PACKAGE_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "")
        PLUGIN_VERSION=$(grep -oP "Version:\s*\K[\d\.]+" blaze-wooless.php 2>/dev/null | head -1 || echo "")

        # Use package.json as primary source, fallback to plugin file
        if [ -n "$PACKAGE_VERSION" ]; then
          CURRENT_VERSION="$PACKAGE_VERSION"
          echo "üì¶ Using version from package.json: $CURRENT_VERSION"
        elif [ -n "$PLUGIN_VERSION" ]; then
          CURRENT_VERSION="$PLUGIN_VERSION"
          echo "üîå Using version from plugin file: $CURRENT_VERSION"
        else
          echo "‚ùå Error: Could not extract current version from any source"
          exit 1
        fi

        # Get commit messages and changed files for analysis
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -n "$LAST_TAG" ]; then
          COMMIT_MESSAGES=$(git log ${LAST_TAG}..HEAD --oneline --no-merges)
          CHANGED_FILES=$(git diff --name-only ${LAST_TAG}..HEAD)
          echo "üìä Analyzing commits since tag: $LAST_TAG"
        else
          COMMIT_MESSAGES=$(git log --oneline --no-merges -10)
          CHANGED_FILES=$(git diff --name-only HEAD~10..HEAD 2>/dev/null || git ls-files)
          echo "üìä Analyzing recent commits (no previous tags found)"
        fi

        # Export environment variables for scripts
        export CURRENT_VERSION="$CURRENT_VERSION"
        export COMMIT_MESSAGES="$COMMIT_MESSAGES"
        export CHANGED_FILES="$CHANGED_FILES"
        export GITHUB_REF="$GITHUB_REF"
        export PR_TITLE="${{ github.event.pull_request.title || '' }}"
        export PR_BODY="${{ github.event.pull_request.body || '' }}"

        echo "üîç Running commit parser script..."
        if node .github/scripts/commit-parser.js; then
          echo "‚úÖ Commit parser completed successfully"
        else
          echo "‚ö†Ô∏è Commit parser failed, continuing with standard analysis"
        fi

        echo "üîç Running version analyzer script..."
        if node .github/scripts/version-analyzer.js; then
          echo "‚úÖ Version analyzer completed successfully"
        else
          echo "‚ö†Ô∏è Version analyzer failed, continuing with standard analysis"
        fi

    - name: Preview version bump
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.BUMP_TYPE != 'none'
      run: |
        echo "üîç Calculating new version based on bump type and current version..."

        # Get current version from package.json (reliable method)
        CURRENT_VERSION=$(node -p "require('./package.json').version" 2>/dev/null)
        if [ $? -ne 0 ] || [ -z "$CURRENT_VERSION" ]; then
          echo "‚ùå Error: Could not extract current version from package.json"
          echo "üîç Debugging: Checking if package.json exists and is valid..."
          if [ ! -f "package.json" ]; then
            echo "‚ùå package.json file not found"
          else
            echo "üìÑ package.json exists, checking content..."
            head -5 package.json
          fi
          exit 1
        fi

        echo "üì¶ Successfully extracted current version: $CURRENT_VERSION"

        echo "üì¶ Current version: $CURRENT_VERSION"
        echo "üîÑ Bump type: ${{ steps.bump_type.outputs.BUMP_TYPE }}"

        # Calculate new version with prerelease support and error handling
        PRERELEASE_TYPE="${{ steps.prerelease_type.outputs.PRERELEASE }}"
        echo "üè∑Ô∏è  Prerelease type: ${PRERELEASE_TYPE:-'none (stable release)'}"

        # Validate semver-utils script exists and implement proper fallback (Claude's recommendation)
        USE_FALLBACK_CALCULATION=false
        if [ ! -f "scripts/semver-utils.js" ]; then
          echo "‚ö†Ô∏è  Warning: semver-utils.js not found, using fallback version calculation"
          echo "   Expected: scripts/semver-utils.js"
          echo "   Fallback: Using built-in bash version calculation"
          USE_FALLBACK_CALCULATION=true
        fi

        if [ "$USE_FALLBACK_CALCULATION" = "true" ]; then
          # Fallback version calculation using bash (no external dependencies)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          case "${{ steps.bump_type.outputs.BUMP_TYPE }}" in
            "major")
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            "minor")
              NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
              ;;
            "patch")
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
              ;;
          esac

          # Add prerelease suffix if specified
          if [ -n "$PRERELEASE_TYPE" ]; then
            NEW_VERSION="$NEW_VERSION-$PRERELEASE_TYPE.1"
          fi
        else
          # SECURITY FIX: Use secure temp script approach to prevent shell injection
          # Create temporary script for secure version calculation
          TEMP_FILE=$(mktemp "${TMPDIR:-/tmp}/version_calc.XXXXXXXXXX.js")
          trap 'rm -f "$TEMP_FILE"' EXIT
          cat > "$TEMP_FILE" << 'EOF'
          const semver = require('./scripts/semver-utils');
          const bumpType = process.env.BUMP_TYPE;
          const currentVersion = process.env.CURRENT_VERSION;
          const prereleaseType = process.env.PRERELEASE_TYPE || null;

          try {
            const newVersion = semver.incrementVersion(currentVersion, bumpType, prereleaseType);
            console.log(newVersion);
          } catch (error) {
            console.error('Error calculating version:', error.message);
            process.exit(1);
          }
          EOF

          # Set environment variables securely
          export BUMP_TYPE="${{ steps.bump_type.outputs.BUMP_TYPE }}"
          export CURRENT_VERSION="$CURRENT_VERSION"
          export PRERELEASE_TYPE="$PRERELEASE_TYPE"

          # Execute secure script with error handling
          echo "üîÑ Executing version calculation script..."
          NEW_VERSION=$(node "$TEMP_FILE" 2>&1)
          EXIT_CODE=$?

          if [ $EXIT_CODE -ne 0 ]; then
            echo "‚ùå Error: Version calculation script failed with exit code $EXIT_CODE"
            echo "üìã Error output: $NEW_VERSION"
            echo "üîÑ Falling back to bash version calculation..."

            # Fallback to bash calculation
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            case "${{ steps.bump_type.outputs.BUMP_TYPE }}" in
              "major") NEW_VERSION="$((MAJOR + 1)).0.0" ;;
              "minor") NEW_VERSION="$MAJOR.$((MINOR + 1)).0" ;;
              "patch") NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))" ;;
              *) echo "‚ùå Unknown bump type: ${{ steps.bump_type.outputs.BUMP_TYPE }}"; exit 1 ;;
            esac

            if [ -n "$PRERELEASE_TYPE" ]; then
              NEW_VERSION="$NEW_VERSION-$PRERELEASE_TYPE.1"
            fi

            echo "‚úÖ Fallback calculation successful: $NEW_VERSION"
          else
            echo "‚úÖ Version calculation successful: $NEW_VERSION"
          fi
        fi

        # Enhanced validation for calculated version (Claude's recommendation)
        if [ -z "$NEW_VERSION" ]; then
          echo "‚ùå Error: NEW_VERSION was not calculated properly"
          echo "   Current version: $CURRENT_VERSION"
          echo "   Bump type: ${{ steps.bump_type.outputs.BUMP_TYPE }}"
          echo "   Fallback calculation: $USE_FALLBACK_CALCULATION"
          exit 1
        fi

        # Validate that the new version is actually different from current version
        if [ "$NEW_VERSION" = "$CURRENT_VERSION" ]; then
          echo "‚ö†Ô∏è  Warning: New version ($NEW_VERSION) is same as current version ($CURRENT_VERSION)"
          echo "   This may indicate an issue with version calculation logic"
        fi

        # Validate that the new version follows semver format (using simplified regex)
        if ! echo "$NEW_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$'; then
          echo "‚ùå Error: Calculated NEW_VERSION '$NEW_VERSION' is not a valid semver format"
          echo "   This indicates a bug in the version calculation logic"
          echo "   Current version: $CURRENT_VERSION"
          echo "   Bump type: ${{ steps.bump_type.outputs.BUMP_TYPE }}"
          echo "   Fallback used: $USE_FALLBACK_CALCULATION"
          exit 1
        fi

        # Handle edge case: Version conflict resolution
        # This occurs when conventional commits would result in the same version as current
        # (e.g., when no conventional commits are found but BUMP_TYPE was determined)
        # Solution: Force a patch increment to ensure version progression
        if [ "$NEW_VERSION" = "$CURRENT_VERSION" ]; then
          echo "‚ö†Ô∏è  Version conflict detected:"
          echo "   Current version: $CURRENT_VERSION"
          echo "   Calculated version: $NEW_VERSION"
          echo "üîÑ Auto-resolving by forcing patch version increment..."

          # SECURITY FIX: Force patch increment using secure temp script
          TEMP_PATCH_FILE=$(mktemp "${TMPDIR:-/tmp}/force_patch.XXXXXXXXXX.js")
          trap 'rm -f "$TEMP_PATCH_FILE"' EXIT
          cat > "$TEMP_PATCH_FILE" << 'EOF'
          const semver = require('./scripts/semver-utils');
          const currentVersion = process.env.CURRENT_VERSION;

          try {
            const newVersion = semver.incrementVersion(currentVersion, 'patch');
            console.log(newVersion);
          } catch (error) {
            console.error('Error incrementing version:', error.message);
            process.exit(1);
          }
          EOF

          # Set environment variable securely
          export CURRENT_VERSION="$CURRENT_VERSION"

          # Execute secure script
          FORCED_VERSION=$(node "$TEMP_PATCH_FILE")

          # Validate the forced version was generated successfully
          if [ $? -eq 0 ] && [ -n "$FORCED_VERSION" ]; then
            NEW_VERSION="$FORCED_VERSION"
            echo "‚úÖ Version conflict resolved:"
            echo "   New version: $NEW_VERSION"
            echo "   Bump type: PATCH (auto-forced)"
            echo "BUMP_TYPE=patch" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Error: Failed to generate forced patch version"
            exit 1
          fi
        fi

        # Enhanced auto-increment logic using extracted conflict resolution module
        # Addresses Claude AI recommendation to extract complex workflow logic
        echo "üîç Starting version conflict resolution..."

        PRERELEASE_TYPE="${{ steps.prerelease_type.outputs.PRERELEASE }}"

        # Use the extracted conflict resolution script for better maintainability
        # Validate script existence before execution to prevent race conditions
        # Claude's recommendation: Consider if script should be required or improve fallback handling
        if [ ! -f "scripts/resolve-version-conflicts.js" ]; then
          echo "‚ö†Ô∏è  Conflict resolution script not found, using calculated version"
          echo "   Expected: scripts/resolve-version-conflicts.js"
          echo "   Impact: Advanced conflict resolution features will be unavailable"
          echo "   Fallback: Using calculated version without conflict resolution"
          echo "   Recommendation: Add the script for enhanced version conflict handling"
          RESOLVED_VERSION="$NEW_VERSION"
          echo "üì¶ Resolved version (fallback): $RESOLVED_VERSION"
        else
          echo "üîß Running conflict resolution script..."
          RESOLUTION_RESULT=$(node scripts/resolve-version-conflicts.js "$NEW_VERSION" "$PRERELEASE_TYPE")
          RESOLUTION_EXIT_CODE=$?

          if [ $RESOLUTION_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Version conflict resolution failed"
            echo "$RESOLUTION_RESULT"
            echo "üîÑ Fallback: Using calculated version without conflict resolution"
            RESOLVED_VERSION="$NEW_VERSION"
          else
            # Extract resolved version from output
            RESOLVED_VERSION=$(echo "$RESOLUTION_RESULT" | grep "üì¶ Final resolved version:" | sed 's/.*: //')

            # Validate that a resolved version was extracted
            if [ -z "$RESOLVED_VERSION" ]; then
              echo "‚ö†Ô∏è  Could not extract resolved version from script output"
              echo "üîÑ Fallback: Using calculated version without conflict resolution"
              RESOLVED_VERSION="$NEW_VERSION"
            fi
          fi
        fi

        if [ -n "$RESOLVED_VERSION" ] && [ "$RESOLVED_VERSION" != "$NEW_VERSION" ]; then
          echo "üîÑ Version updated due to conflict resolution:"
          echo "   Original: $NEW_VERSION"
          echo "   Resolved: $RESOLVED_VERSION"
          NEW_VERSION="$RESOLVED_VERSION"

          # Update bump type to patch since we're doing patch increments for resolution
          echo "BUMP_TYPE=patch" >> $GITHUB_OUTPUT
        fi

        echo "üì¶ Final version will be: $NEW_VERSION"
        echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV

    - name: Bump version
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.BUMP_TYPE != 'none'
      run: |
        echo "üîÑ Bumping version using npm scripts..."
        npm run version:${{ steps.bump_type.outputs.BUMP_TYPE }}

        echo "‚úÖ Version bump completed"
        UPDATED_VERSION=$(node -p "require('./package.json').version")
        echo "üì¶ Updated version: $UPDATED_VERSION"

    - name: Update changelog
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.BUMP_TYPE != 'none'
      run: |
        echo "üìù Updating changelog..."
        npm run changelog
        echo "‚úÖ Changelog updated"

    - name: Validate post-bump version system
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.BUMP_TYPE != 'none'
      run: |
        echo "üîç Validating version system after bump..."
        FINAL_VERSION=$(node -p "require('./package.json').version")
        echo "üì¶ Validating final version: $FINAL_VERSION"

        # Use --no-conflicts flag since we've already resolved conflicts in the bump process
        node scripts/validate-version.js --verbose --no-conflicts
        if [ $? -ne 0 ]; then
          echo "‚ùå Post-bump validation failed. This indicates an issue with the version update process."
          echo "   Final version: $FINAL_VERSION"
          echo "   This suggests a problem with file consistency or version format."
          exit 1
        fi

        # Additional verification: Ensure git tag was created successfully
        TAG_NAME="v$FINAL_VERSION"
        if git rev-parse --verify "$TAG_NAME" >/dev/null 2>&1; then
          echo "‚úÖ Git tag $TAG_NAME exists and is valid"
        else
          echo "‚ö†Ô∏è  Git tag $TAG_NAME was not found (this is expected - tag will be created during commit)"
        fi

        echo "‚úÖ Post-bump validation passed successfully"
        echo "üì¶ All version files are consistent at version: $FINAL_VERSION"

    - name: Commit version bump
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.BUMP_TYPE != 'none'
      run: |
        VERSION=$(node -p "require('./package.json').version")
        echo "üìù Committing version bump to $VERSION..."

        # Debug git status
        echo "üîç Git status before commit:"
        git status --porcelain

        # Add all changes
        git add .

        # Verify there are changes to commit
        if git diff --cached --quiet; then
          echo "‚ö†Ô∏è  No changes to commit after git add"
          git status
          exit 1
        fi

        # Create commit with detailed message
        git commit -m "chore(release): bump version to $VERSION [skip ci]

        ü§ñ Automated version bump
        üì¶ Version: $VERSION
        üîÑ Bump type: ${{ steps.bump_type.outputs.BUMP_TYPE }}
        üìù Updated files: package.json, blaze-wooless.php, blocks/package.json, docs/reference/changelog.md"

        # Verify commit was created
        if [ $? -ne 0 ]; then
          echo "‚ùå Failed to create commit"
          echo "üîç Git status after failed commit:"
          git status
          exit 1
        fi

        echo "‚úÖ Commit created successfully"
        echo "üîç Latest commit:"
        git log --oneline -1

        echo "üöÄ Pushing changes..."
        if ! git push; then
          echo "‚ùå Failed to push changes"
          echo "üîç Git remote info:"
          git remote -v
          echo "üîç Current branch:"
          git branch --show-current
          exit 1
        fi

        echo "‚úÖ Version bump completed and pushed successfully!"

    - name: Workflow Summary
      if: always()
      run: |
        echo "üìã Auto Version Bump Workflow Summary"
        echo "======================================"

        if [ "${{ steps.check_files.outputs.should_bump_version }}" = "true" ]; then
          echo "‚úÖ Version bump was processed"
          echo "üîÑ Bump type: ${{ steps.bump_type.outputs.BUMP_TYPE || 'none' }}"
          if [ "${{ steps.bump_type.outputs.BUMP_TYPE }}" != "none" ] && [ -n "${{ steps.bump_type.outputs.BUMP_TYPE }}" ]; then
            # Safely get the final version with error handling
            if [ -f "package.json" ]; then
              FINAL_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "unknown")
            else
              FINAL_VERSION="unknown (package.json not found)"
            fi
            echo "üì¶ New version: $FINAL_VERSION"
            echo "üéâ Version bump completed successfully!"
          else
            echo "‚ÑπÔ∏è  No version bump was needed (no conventional commits found)"
          fi
        else
          echo "‚è≠Ô∏è  Version bump was skipped"
          echo "üìÅ Reason: Only ignored files were changed"
          echo "‚ÑπÔ∏è  This is normal behavior - no version bump needed for:"
          echo "   ‚Ä¢ Documentation changes"
          echo "   ‚Ä¢ CI/CD configuration updates"
          echo "   ‚Ä¢ Development tooling changes"
          echo "   ‚Ä¢ Auto-generated files"
          echo ""
          echo "‚úÖ Workflow completed successfully (no action required)"
        fi
