name: "Priority 4: Auto Version Bump"

"on":
  push:
    branches:
      - main
      - develop
      - 'feature/**'
      - 'release/**'

# Priority 4: Post-approval workflow - runs ONLY after PR is approved and Priority 3 completes
concurrency:
  group: priority-4-auto-version-${{ github.repository }}
  cancel-in-progress: false  # Don't cancel to ensure version consistency

jobs:
  # Wait for Priority 3 (Claude Approval Gate) to complete before proceeding
  wait-for-priority-3:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ vars.PRIORITY_DEPENDENCY_TIMEOUT || 5 }}
    outputs:
      priority-3-completed: ${{ steps.check-dependencies.outputs.all_dependencies_completed }}
      pr-approved: ${{ steps.check-approval.outputs.approved }}
    steps:
      - name: Check Priority 3 Dependencies
        id: check-dependencies
        uses: actions/github-script@v7
        with:
          script: |
            console.log('DEBUG: Checking Priority 3 workflow completion...');

            // Get all workflow runs for this commit
            const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: context.sha,
              status: 'completed'
            });

            // Look for completed Priority 3 workflows
            const priority3Workflows = ['Priority 3: Claude AI Approval Gate'];
            let allCompleted = true;

            for (const workflowName of priority3Workflows) {
              const workflow = workflowRuns.workflow_runs.find(run =>
                run.name === workflowName && run.head_sha === context.sha
              );

              if (workflow) {
                console.log(`SUCCESS: ${workflowName} completed with status: ${workflow.conclusion}`);
              } else {
                console.log(`PENDING: ${workflowName} not yet completed`);
                allCompleted = false;
              }
            }

            core.setOutput('all_dependencies_completed', allCompleted.toString());

      - name: Check PR Approval Status
        id: check-approval
        uses: actions/github-script@v7
        with:
          script: |
            console.log('DEBUG: Checking PR approval status...');

            // Get PR number from commit
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha
            });

            if (prs.length === 0) {
              console.log('INFO: No PR associated with this commit - proceeding with version bump');
              core.setOutput('approved', 'true');
              return;
            }

            const pr = prs[0];
            console.log(`INFO: Checking approval status for PR #${pr.number}`);

            // Check for BlazeCommerce Automation Bot approval
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            const claudeApproval = reviews.find(review =>
              (review.user.login === 'blazecommerce-claude-ai' ||
               review.user.type === 'Bot' && review.user.login.includes('blazecommerce-automation')) &&
              review.state === 'APPROVED'
            );

            if (claudeApproval) {
              console.log('SUCCESS: PR is approved by BlazeCommerce Automation Bot');
              core.setOutput('approved', 'true');
            } else {
              console.log('WARNING: PR is not yet approved by BlazeCommerce Automation Bot');
              core.setOutput('approved', 'false');
            }

  # Job that runs on feature branches to provide feedback but skip version operations
  feature-branch-info:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: github.ref != 'refs/heads/main'
    steps:
      - name: Feature Branch Information
        run: |
          echo "‚ÑπÔ∏è  Auto Version Bump - Feature Branch Mode"
          echo "=========================================="
          echo "Current branch: ${{ github.ref_name }}"
          echo "Target branch for version bumps: main"
          echo ""
          echo "üìã Status: Version bump operations are SKIPPED on feature branches"
          echo "‚úÖ This is expected behavior to prevent version conflicts"
          echo ""
          echo "üîÑ Version bumps will execute when:"
          echo "   - Changes are merged to the main branch"
          echo "   - Conventional commit messages are detected"
          echo "   - No [skip ci] or [no version] flags are present"
          echo ""
          echo "üí° To test version bump logic locally:"
          echo "   npm run test:version-system"
          echo "   npm run validate-version"
          echo ""
          echo "SUCCESS: Feature branch validation completed"

  version-bump:
    needs: [wait-for-priority-3]
    runs-on: ubuntu-latest
    timeout-minutes: ${{ vars.AUTO_VERSION_TIMEOUT || 20 }}
    if: |
      github.ref == 'refs/heads/main' &&
      needs.wait-for-priority-3.outputs.pr-approved == 'true' &&
      !contains(github.event.head_commit.message, '[skip ci]') &&
      !contains(github.event.head_commit.message, 'chore(release)') &&
      !contains(github.event.head_commit.message, '[no version]')
    permissions:
      # Minimum required permissions for auto-version workflow
      contents: write         # Required: Update version files and create commits
      pull-requests: read     # Required: Read PR information for version analysis
      actions: read           # Required: Read workflow run information
      # Security: All other permissions explicitly denied (no issues, packages, etc.)

    steps:
    - name: Generate GitHub App Token
      id: app_token
      if: env.BC_GITHUB_APP_ID != '' && env.BC_GITHUB_APP_PRIVATE_KEY != ''
      env:
        BC_GITHUB_APP_ID: ${{ secrets.BC_GITHUB_APP_ID }}
        BC_GITHUB_APP_PRIVATE_KEY: ${{ secrets.BC_GITHUB_APP_PRIVATE_KEY }}
      uses: actions/create-github-app-token@v1
      with:
        app-id: ${{ secrets.BC_GITHUB_APP_ID }}
        private-key: ${{ secrets.BC_GITHUB_APP_PRIVATE_KEY }}
        owner: ${{ github.repository_owner }}
        repositories: ${{ github.event.repository.name }}
        # Individual permission parameters (required format for this action)
        permission-contents: write
        permission-metadata: read
        permission-pull-requests: read
        permission-actions: read
        permission-administration: read

    - name: Verify GitHub App Token
      if: steps.app_token.outputs.token
      run: |
        echo "‚úÖ GitHub App token generated successfully"
        echo "ü§ñ Using blazecommerce-automation-bot identity"
        echo "üîê Token length: $(echo '${{ steps.app_token.outputs.token }}' | wc -c)"

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ steps.app_token.outputs.token || secrets.BC_GITHUB_TOKEN || github.token }}
        fetch-depth: 0

    - name: Pull Latest Changes to Prevent Version Conflicts
      run: |
        echo "INFO: Pulling latest changes to prevent version conflicts..."
        git fetch origin main
        git reset --hard origin/main
        echo "SUCCESS: Repository updated to latest main branch"

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: |
        echo "DEBUG: Installing Node.js dependencies for version management..."

        # Check if package.json exists
        if [ ! -f "package.json" ]; then
          echo "ERROR: package.json not found"
          exit 1
        fi

        # Install dependencies with error handling
        npm install --no-audit --no-fund
        echo "SUCCESS: Node.js dependencies installed successfully"

    - name: Check if version bump is needed
      id: check_files
      run: |
        echo "DEBUG: Running file change analysis..."

        # COMPREHENSIVE SECURITY: Advanced token exposure prevention
        echo "üîí SECURITY: Implementing secure environment variable handling"

        # Create isolated environment for sensitive operations
        set +x  # Disable command echoing to prevent token leakage in logs

        # Multi-layer input validation and sanitization
        GITHUB_EVENT_BEFORE_RAW="${{ github.event.before }}"
        DEBUG_MODE_RAW="${{ vars.DEBUG_MODE || 'false' }}"

        # Comprehensive validation with multiple security checks
        if [[ -z "$GITHUB_EVENT_BEFORE_RAW" ]]; then
          echo "üö® SECURITY: Empty GITHUB_EVENT_BEFORE, using safe default"
          export GITHUB_EVENT_BEFORE="0000000000000000000000000000000000000000"
        elif [[ ${#GITHUB_EVENT_BEFORE_RAW} -ne 40 ]]; then
          echo "üö® SECURITY: Invalid GITHUB_EVENT_BEFORE length (${#GITHUB_EVENT_BEFORE_RAW}), expected 40"
          export GITHUB_EVENT_BEFORE="0000000000000000000000000000000000000000"
        elif [[ "$GITHUB_EVENT_BEFORE_RAW" =~ ^[a-f0-9]{40}$ ]]; then
          export GITHUB_EVENT_BEFORE="$GITHUB_EVENT_BEFORE_RAW"
          echo "‚úÖ SECURITY: GITHUB_EVENT_BEFORE validation passed"
        else
          echo "üö® SECURITY: GITHUB_EVENT_BEFORE contains invalid characters, using safe default"
          export GITHUB_EVENT_BEFORE="0000000000000000000000000000000000000000"
        fi

        # Secure debug mode validation
        if [[ "$DEBUG_MODE_RAW" =~ ^(true|false)$ ]]; then
          export DEBUG="$DEBUG_MODE_RAW"
          echo "‚úÖ SECURITY: DEBUG mode validation passed: $DEBUG"
        else
          export DEBUG="false"
          echo "üö® SECURITY: Invalid DEBUG_MODE value, defaulting to false"
        fi

        # Additional security: Clear potentially sensitive variables
        unset GITHUB_EVENT_BEFORE_RAW DEBUG_MODE_RAW

        # Re-enable command echoing for non-sensitive operations
        set -x

        # Check if the script exists
        if [ ! -f ".github/scripts/file-change-analyzer.js" ]; then
          echo "WARNING: File change analyzer script not found, using fallback logic..."

          # Simple fallback: check if any significant files changed
          if [ -n "$GITHUB_EVENT_BEFORE" ] && [ "$GITHUB_EVENT_BEFORE" != "0000000000000000000000000000000000000000" ]; then
            CHANGED_FILES=$(git diff --name-only $GITHUB_EVENT_BEFORE..HEAD || echo "")
            if [ -n "$CHANGED_FILES" ]; then
              echo "should_bump_version=true" >> $GITHUB_OUTPUT
              echo "change_reason=Files changed (fallback analysis)" >> $GITHUB_OUTPUT
            else
              echo "should_bump_version=false" >> $GITHUB_OUTPUT
              echo "change_reason=No files changed" >> $GITHUB_OUTPUT
            fi
          else
            echo "should_bump_version=true" >> $GITHUB_OUTPUT
            echo "change_reason=First push or no before commit" >> $GITHUB_OUTPUT
          fi
          echo "SUCCESS: Fallback file change analysis completed"
        else
          # Run the extracted file change analyzer
          if node .github/scripts/file-change-analyzer.js; then
            echo "SUCCESS: File change analysis completed successfully"
          else
            echo "ERROR: File change analysis failed"
            exit 1
          fi
        fi

    - name: Configure Git
      if: steps.check_files.outputs.should_bump_version == 'true'
      run: |
        # Use GitHub App identity if available, otherwise fall back to github-actions bot
        if [ -n "${{ steps.app_token.outputs.token }}" ]; then
          git config --local user.email "blazecommerce-automation-bot[bot]@users.noreply.github.com"
          git config --local user.name "blazecommerce-automation-bot[bot]"
          echo "‚úÖ Git configured for blazecommerce-automation-bot[bot]"
          echo "üîê Using GitHub App authentication with bypass permissions"
        else
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          echo "‚ö†Ô∏è Fallback: Git configured for GitHub Actions bot"
        fi

        # Verify git configuration
        echo "üìß Git user.email: $(git config user.email)"
        echo "üë§ Git user.name: $(git config user.name)"

    - name: Run version system tests
      if: steps.check_files.outputs.should_bump_version == 'true'
      run: |
        echo "TESTING: Running version system tests..."

        # Check if test script exists before running
        if npm run test:version-system --silent 2>/dev/null; then
          echo "SUCCESS: Version system tests passed"
        elif [ $? -eq 127 ] || ! npm run | grep -q "test:version-system"; then
          echo "WARNING:  test:version-system script not found, running fallback validation..."

          # Fallback: Basic validation of core functions
          node -e "
            try {
              const semver = require('./scripts/semver-utils');
              console.log('SUCCESS: semver-utils module loads successfully');

              // Test basic functions exist
              if (typeof semver.incrementVersion !== 'function') throw new Error('incrementVersion function missing');
              if (typeof semver.findNextAvailableVersion !== 'function') throw new Error('findNextAvailableVersion function missing');
              if (typeof semver.tagExists !== 'function') throw new Error('tagExists function missing');

              console.log('SUCCESS: Core functions are available');
              console.log('SUCCESS: Fallback validation passed');
            } catch (error) {
              console.error('ERROR: Fallback validation failed:', error.message);
              process.exit(1);
            }
          "
        else
          echo "ERROR: Version system tests failed. Aborting version bump."
          echo "   Exit code: $?"
          echo "   Please check test implementation and dependencies"
          exit 1
        fi

    - name: Validate current version system
      if: steps.check_files.outputs.should_bump_version == 'true'
      id: version_validation
      run: |
        echo "DEBUG: Running version validation..."

        # Check if the script exists
        if [ ! -f ".github/scripts/version-validator.js" ]; then
          echo "WARNING: Version validator script not found, using fallback logic..."

          # Simple fallback: get version from package.json
          if [ -f "package.json" ]; then
            PACKAGE_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "1.0.0")
            echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
            echo "version_mismatch=false" >> $GITHUB_OUTPUT
            echo "last_tag=" >> $GITHUB_OUTPUT
            echo "SUCCESS: Fallback version validation completed"
          else
            echo "ERROR: No package.json found"
            exit 1
          fi
        else
          # Run the extracted version validator
          if node .github/scripts/version-validator.js; then
            echo "SUCCESS: Version validation completed successfully"
          else
            echo "ERROR: Version validation failed"
            exit 1
          fi
        fi

    - name: Determine prerelease type based on branch
      if: steps.check_files.outputs.should_bump_version == 'true'
      id: prerelease_type
      run: |
        echo "BRANCH: Running branch analysis..."

        # Set environment variables for the script
        export GITHUB_REF="${{ github.ref }}"

        # Check if the script exists
        if [ ! -f ".github/scripts/branch-analyzer.js" ]; then
          echo "WARNING: Branch analyzer script not found, using fallback logic..."

          # Simple fallback: determine prerelease type from branch name
          BRANCH_NAME=$(echo "$GITHUB_REF" | sed 's|refs/heads/||')

          if [[ "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "master" ]]; then
            echo "prerelease_type=" >> $GITHUB_OUTPUT
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          elif [[ "$BRANCH_NAME" == "develop" ]]; then
            echo "prerelease_type=beta" >> $GITHUB_OUTPUT
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          elif [[ "$BRANCH_NAME" == release/* ]]; then
            echo "prerelease_type=rc" >> $GITHUB_OUTPUT
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "prerelease_type=alpha" >> $GITHUB_OUTPUT
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          fi
          echo "SUCCESS: Fallback branch analysis completed"
        else
          # Run the extracted branch analyzer
          if node .github/scripts/branch-analyzer.js; then
            echo "SUCCESS: Branch analysis completed successfully"
          else
            echo "ERROR: Branch analysis failed"
            exit 1
          fi
        fi

    - name: Determine version bump type
      if: steps.check_files.outputs.should_bump_version == 'true'
      id: bump_type
      run: |
        echo "DEBUG: Running commit analysis for bump type..."
        echo "üîç Workflow Debug Information:"
        echo "   - Trigger event: ${{ github.event_name }}"
        echo "   - Head commit: ${{ github.event.head_commit.message }}"
        echo "   - Ref: ${{ github.ref }}"
        echo "   - Should bump version: ${{ steps.check_files.outputs.should_bump_version }}"
        echo "   - Change reason: ${{ steps.check_files.outputs.change_reason }}"

        # Set environment variables for the script
        export VERSION_MISMATCH="${{ steps.version_validation.outputs.version_mismatch }}"
        export LAST_TAG="${{ steps.version_validation.outputs.last_tag }}"
        export LIMITED_COMMIT_LIMIT="${{ vars.LIMITED_COMMIT_LIMIT || '25' }}"
        export FALLBACK_COMMIT_LIMIT="${{ vars.FALLBACK_COMMIT_LIMIT || '50' }}"

        # Check if the script exists
        if [ ! -f ".github/scripts/bump-type-analyzer.js" ]; then
          echo "WARNING: Bump type analyzer script not found, using fallback logic..."

          # Simple fallback: determine bump type from recent commits
          if [ "$VERSION_MISMATCH" = "true" ]; then
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "reason=Version mismatch fix" >> $GITHUB_OUTPUT
          else
            # Check recent commit messages for conventional commit patterns
            RECENT_COMMITS=$(git log --oneline -10 --pretty=format:"%s" 2>/dev/null || echo "")

            if echo "$RECENT_COMMITS" | grep -qE "^(feat|feature)(\(.+\))?:"; then
              echo "bump_type=minor" >> $GITHUB_OUTPUT
              echo "reason=Feature commits detected" >> $GITHUB_OUTPUT
            elif echo "$RECENT_COMMITS" | grep -qE "^(fix|bugfix|hotfix)(\(.+\))?:"; then
              echo "bump_type=patch" >> $GITHUB_OUTPUT
              echo "reason=Fix commits detected" >> $GITHUB_OUTPUT
            elif echo "$RECENT_COMMITS" | grep -qE "BREAKING CHANGE|!:"; then
              echo "bump_type=major" >> $GITHUB_OUTPUT
              echo "reason=Breaking changes detected" >> $GITHUB_OUTPUT
            else
              echo "bump_type=patch" >> $GITHUB_OUTPUT
              echo "reason=Default patch bump" >> $GITHUB_OUTPUT
            fi
          fi
          echo "SUCCESS: Fallback bump type analysis completed"
        else
          # Check if intelligent analysis is available and successful
          if [ "${{ steps.intelligent_analysis.outputs.intelligent_analysis_available }}" = "true" ]; then
            echo "‚úÖ Using results from intelligent analysis (already completed)"
            echo "SUCCESS: Intelligent bump type analysis completed successfully"

            # Add gap detection summary to output
            if [ "${{ steps.intelligent_analysis.outputs.gaps_detected }}" = "true" ]; then
              echo "‚ö†Ô∏è  Gap Detection Summary: Version gaps were detected"
              echo "   This indicates commits that should have triggered version bumps but didn't"
              echo "   The intelligent analysis has adjusted the bump type accordingly"
            else
              echo "‚úÖ Gap Detection Summary: No version gaps detected"
            fi
          else
            echo "üîÑ Intelligent analysis not available, using traditional analysis..."
            # Run the traditional bump type analyzer
            if node .github/scripts/bump-type-analyzer.js "$VERSION_MISMATCH" "$LAST_TAG" "false"; then
              echo "SUCCESS: Traditional bump type analysis completed successfully"
            else
              echo "ERROR: Bump type analysis failed"
              exit 1
            fi
          fi
        fi

    - name: Intelligent commit analysis with gap detection
      if: steps.check_files.outputs.should_bump_version == 'true'
      id: intelligent_analysis
      run: |
        echo "üîç Running intelligent commit analysis with gap detection..."

        # Set environment variables for intelligent analysis
        export VERSION_MISMATCH="${{ steps.version_validation.outputs.version_mismatch }}"
        export LAST_TAG="${{ steps.version_validation.outputs.last_tag }}"
        export USE_INTELLIGENT_ANALYSIS="true"
        export ENABLE_GAP_DETECTION="true"
        export LIMITED_COMMIT_LIMIT="${{ vars.LIMITED_COMMIT_LIMIT || '25' }}"
        export FALLBACK_COMMIT_LIMIT="${{ vars.FALLBACK_COMMIT_LIMIT || '50' }}"

        echo "üîß Intelligent Analysis Configuration:"
        echo "   - Version mismatch: $VERSION_MISMATCH"
        echo "   - Last tag: $LAST_TAG"
        echo "   - Gap detection: enabled"
        echo "   - Cumulative analysis: enabled"

        # Check if the enhanced script exists
        if [ ! -f ".github/scripts/bump-type-analyzer.js" ]; then
          echo "WARNING: Enhanced bump type analyzer not found, skipping intelligent analysis..."
          echo "intelligent_analysis_available=false" >> $GITHUB_OUTPUT
          echo "gap_detection_enabled=false" >> $GITHUB_OUTPUT
        else
          # Run intelligent analysis
          echo "üöÄ Running intelligent commit analysis..."
          if node .github/scripts/bump-type-analyzer.js "$VERSION_MISMATCH" "$LAST_TAG" "true"; then
            echo "‚úÖ Intelligent analysis completed successfully"
            echo "intelligent_analysis_available=true" >> $GITHUB_OUTPUT
            echo "gap_detection_enabled=true" >> $GITHUB_OUTPUT

            # Check if gap detection found any issues
            if grep -q "Gap detection:" /tmp/github_output.txt 2>/dev/null; then
              echo "‚ö†Ô∏è  Version gaps detected - see analysis output"
              echo "gaps_detected=true" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ No version gaps detected"
              echo "gaps_detected=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå Intelligent analysis failed, will use traditional analysis"
            echo "intelligent_analysis_available=false" >> $GITHUB_OUTPUT
            echo "gap_detection_enabled=false" >> $GITHUB_OUTPUT
            echo "gaps_detected=false" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Pre-validate version conflicts
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.bump_type != 'none'
      id: pre_validate
      run: |
        echo "üîç Pre-validating for version conflicts..."

        CURRENT_VERSION="${{ steps.version_validation.outputs.package_version }}"
        BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"

        echo "üì¶ Current version: $CURRENT_VERSION"
        echo "üîß Planned bump type: $BUMP_TYPE"

        # Check if current version tag already exists
        if git tag | grep -q "v$CURRENT_VERSION"; then
          echo "‚ö†Ô∏è  Tag conflict detected: v$CURRENT_VERSION already exists"
          echo "üîß Pre-resolving version conflict..."

          # Find next available version
          RESOLVED_VERSION=$(node -e "
            const semver = require('./scripts/semver-utils');
            const nextVersion = semver.findNextAvailableVersion('$CURRENT_VERSION', '$BUMP_TYPE');
            console.log(nextVersion);
          ")

          if [ -n "$RESOLVED_VERSION" ] && [ "$RESOLVED_VERSION" != "undefined" ]; then
            echo "‚úÖ Resolved version: $RESOLVED_VERSION"
            echo "resolved_version=$RESOLVED_VERSION" >> $GITHUB_OUTPUT
            echo "has_conflict=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to resolve version conflict"
            exit 1
          fi
        else
          echo "‚úÖ No version conflicts detected"
          echo "has_conflict=false" >> $GITHUB_OUTPUT
          echo "resolved_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        fi

    - name: Execute version bump
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.bump_type != 'none'
      run: |
        echo "EXECUTING: Executing version bump..."

        # Set environment variables for the script
        export BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"
        export PRERELEASE_TYPE="${{ steps.prerelease_type.outputs.prerelease_type }}"
        export PACKAGE_VERSION="${{ steps.pre_validate.outputs.resolved_version }}"
        export AUTO_RESOLVE_CONFLICTS="true"
        export FORCE_VERSION_RESOLUTION="true"
        export HAS_CONFLICT="${{ steps.pre_validate.outputs.has_conflict }}"

        # Run the version update script with enhanced error handling
        echo "üîÑ Starting version update process..."
        echo "üì¶ Target version: $PACKAGE_VERSION"
        echo "üîß Bump type: $BUMP_TYPE"
        echo "üè∑Ô∏è  Prerelease type: ${PRERELEASE_TYPE:-none}"
        echo "‚ö†Ô∏è  Had conflict: $HAS_CONFLICT"

        # If we had a conflict, update package.json first
        if [ "$HAS_CONFLICT" = "true" ]; then
          echo "üîß Updating package.json with resolved version..."
          node -e "
            const fs = require('fs');
            const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            packageJson.version = '$PACKAGE_VERSION';
            fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2) + '\n');
            console.log('‚úÖ Package.json updated with resolved version');
          "
        fi

        if node scripts/update-version.js --force; then
          echo "SUCCESS: Version bump completed successfully"

          # Get the new version for confirmation
          NEW_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "unknown")
          echo "‚úÖ Final version: $NEW_VERSION"
        else
          echo "ERROR: Version bump failed even with conflict resolution"
          echo "üîç Debug information:"
          echo "   Current package.json version: $(node -p "require('./package.json').version" 2>/dev/null || echo "unknown")"
          echo "   Existing tags: $(git tag | grep -E '^v[0-9]' | tail -5)"
          exit 1
        fi

    - name: üîç Validate Version Consistency (Post-Bump)
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.bump_type != 'none'
      run: |
        echo "üîç Validating version consistency after update..."

        # Get the new version
        NEW_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "unknown")
        echo "PACKAGE: Updated version: $NEW_VERSION"

        # Run comprehensive validation
        if [ -f "scripts/validate-version.js" ]; then
          echo "EXECUTING: Running file consistency validation..."
          # Use --no-conflicts flag for post-bump validation to avoid false positives
          if node scripts/validate-version.js --verbose --no-conflicts; then
            echo "SUCCESS: All version files are consistent"
          else
            echo "ERROR: Version files are inconsistent after update"
            echo "üîç Debug information:"
            echo "   package.json: $(node -p "require('./package.json').version" 2>/dev/null || echo "error")"
            echo "   blaze-wooless.php: $(grep -o 'Version: [0-9.]*' blaze-wooless.php | cut -d' ' -f2 || echo "error")"
            echo "   README.md: $(grep -o '\*\*Version:\*\* [0-9.]*' README.md | cut -d' ' -f2 || echo "error")"
            exit 1
          fi
        else
          echo "WARNING: validate-version.js not found, skipping detailed validation"

          # Basic validation fallback
          echo "üîç Running basic version consistency check..."
          PACKAGE_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "")
          PHP_VERSION=$(grep -o 'Version: [0-9.]*' blaze-wooless.php | cut -d' ' -f2 || echo "")
          README_VERSION=$(grep -o '\*\*Version:\*\* [0-9.]*' README.md | cut -d' ' -f2 || echo "")

          echo "   package.json: $PACKAGE_VERSION"
          echo "   blaze-wooless.php: $PHP_VERSION"
          echo "   README.md: $README_VERSION"

          if [ "$PACKAGE_VERSION" = "$PHP_VERSION" ] && [ "$PACKAGE_VERSION" = "$README_VERSION" ]; then
            echo "SUCCESS: Basic version consistency check passed"
          else
            echo "ERROR: Version inconsistency detected in basic check"
            exit 1
          fi
        fi

    - name: üè∑Ô∏è Pre-Tag Validation (Post-Bump Files ‚Üí Git Tag)
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.bump_type != 'none'
      run: |
        echo "üîç Pre-tag validation: Ensuring version consistency before creating git tag..."

        # Get the new version from package.json
        NEW_VERSION=$(node -p "require('./package.json').version")
        echo "PACKAGE: Version to tag: $NEW_VERSION"

        # Run tag-to-files validation (simulated)
        if [ -f "scripts/version-sync-validator.js" ]; then
          echo "EXECUTING: Running comprehensive pre-tag validation..."

          # Create a temporary tag for validation (we'll validate against the version we're about to tag)
          TEMP_TAG="v$NEW_VERSION"
          echo "EXECUTING: Validating consistency for future tag: $TEMP_TAG"

          # Since the tag doesn't exist yet, we'll validate that all files have the same version
          # that we're about to tag (use --no-conflicts since this is post-bump validation)
          if node scripts/validate-version.js --verbose --no-conflicts; then
            echo "SUCCESS: All files are consistent and ready for tagging"
          else
            echo "ERROR: Files are not consistent - cannot create tag"
            echo "üîç This should not happen after version update validation"
            exit 1
          fi
        else
          echo "WARNING: version-sync-validator.js not found, using basic validation"

          # Basic validation
          PACKAGE_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "")
          PHP_VERSION=$(grep -o 'Version: [0-9.]*' blaze-wooless.php | cut -d' ' -f2 || echo "")

          if [ "$PACKAGE_VERSION" != "$PHP_VERSION" ]; then
            echo "ERROR: Version mismatch detected before tagging"
            echo "   package.json: $PACKAGE_VERSION"
            echo "   blaze-wooless.php: $PHP_VERSION"
            exit 1
          fi

          echo "SUCCESS: Basic pre-tag validation passed"
        fi

    - name: Final validation before tag creation
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.bump_type != 'none'
      id: final_validation
      run: |
        echo "üîç Final validation: Ensuring all previous steps completed successfully..."

        # Check that all required outputs are present
        if [ -z "${{ steps.check_files.outputs.should_bump_version }}" ]; then
          echo "ERROR: Missing file check output"
          exit 1
        fi

        if [ -z "${{ steps.bump_type.outputs.bump_type }}" ]; then
          echo "ERROR: Missing bump type output"
          exit 1
        fi

        if [ "${{ steps.bump_type.outputs.bump_type }}" = "none" ]; then
          echo "INFO: No version bump needed, skipping tag creation"
          exit 0
        fi

        # Verify version files are consistent
        NEW_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "")
        if [ -z "$NEW_VERSION" ]; then
          echo "ERROR: Could not read version from package.json"
          exit 1
        fi

        echo "‚úÖ Final validation passed - ready for tag creation"
        echo "version_ready=true" >> $GITHUB_OUTPUT
        echo "final_version=$NEW_VERSION" >> $GITHUB_OUTPUT

    - name: Create git tag
      if: |
        steps.check_files.outputs.should_bump_version == 'true' &&
        steps.bump_type.outputs.bump_type != 'none' &&
        steps.final_validation.outputs.version_ready == 'true' &&
        success()
      run: |
        echo "TAG: Creating git tag..."

        # Get the new version from package.json
        NEW_VERSION=$(node -p "require('./package.json').version")
        TAG_NAME="v$NEW_VERSION"

        echo "üè∑Ô∏è  Preparing to create tag: $TAG_NAME"

        # Check if tag already exists
        if git tag | grep -q "^$TAG_NAME$"; then
          echo "‚ö†Ô∏è  Tag $TAG_NAME already exists"
          echo "üîç Checking if this is the same commit..."

          # Get the commit hash for the existing tag
          EXISTING_TAG_COMMIT=$(git rev-list -n 1 "$TAG_NAME" 2>/dev/null || echo "")
          CURRENT_COMMIT=$(git rev-parse HEAD)

          if [ "$EXISTING_TAG_COMMIT" = "$CURRENT_COMMIT" ]; then
            echo "‚úÖ Tag $TAG_NAME already points to current commit"
            echo "‚ÑπÔ∏è  No action needed - tag is already correct"
          else
            echo "‚ùå Tag $TAG_NAME points to different commit"
            echo "üîß This should not happen after version conflict resolution"
            echo "üìã Existing tag commit: $EXISTING_TAG_COMMIT"
            echo "üìã Current commit: $CURRENT_COMMIT"
            exit 1
          fi
        else
          echo "‚úÖ Tag $TAG_NAME does not exist, creating new tag..."

          # Create and push tag
          if git tag "$TAG_NAME"; then
            echo "‚úÖ Tag created locally: $TAG_NAME"

            # Push tag with GitHub App token (preferred) or admin token fallback
            if [ -n "${{ steps.app_token.outputs.token }}" ]; then
              echo "üè∑Ô∏è Using GitHub App token to push tag (blazecommerce-automation-bot with bypass permissions)"
              git remote set-url origin "https://x-access-token:${{ steps.app_token.outputs.token }}@github.com/${{ github.repository }}.git"
              if git push origin "$TAG_NAME"; then
                echo "‚úÖ Successfully created and pushed tag: $TAG_NAME"
              else
                echo "‚ùå Failed to push tag to remote with GitHub App token"
                echo "üîç Checking git status and remote configuration..."
                git status
                git remote -v
                exit 1
              fi
            elif [ -n "${{ secrets.BC_GITHUB_TOKEN }}" ]; then
              echo "‚ö†Ô∏è Using admin token fallback to push tag"
              git remote set-url origin "https://${{ secrets.BC_GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
              if git push origin "$TAG_NAME"; then
                echo "SUCCESS: Created and pushed tag: $TAG_NAME"
              else
                echo "ERROR: Failed to push tag to remote with admin token"
                exit 1
              fi
            else
              echo "ERROR: No suitable token available for tag push"
              exit 1
            fi
          else
            echo "ERROR: Failed to create tag locally"
            exit 1
          fi
        fi

    - name: Post-tag validation
      if: |
        steps.check_files.outputs.should_bump_version == 'true' &&
        steps.bump_type.outputs.bump_type != 'none' &&
        success()
      run: |
        echo "üîç Post-tag validation: Verifying git tag matches file versions..."

        # Get the new version and tag
        NEW_VERSION=$(node -p "require('./package.json').version")
        TAG_NAME="v$NEW_VERSION"

        echo "TAG: Validating tag: $TAG_NAME"
        echo "PACKAGE: Expected version: $NEW_VERSION"

        # Verify tag was created
        if ! git tag | grep -q "^$TAG_NAME$"; then
          echo "ERROR: Tag $TAG_NAME was not created successfully"
          exit 1
        fi

        # Run comprehensive tag-to-files validation
        if [ -f "scripts/version-sync-validator.js" ]; then
          echo "EXECUTING: Running comprehensive tag-to-files validation..."
          if node scripts/version-sync-validator.js --tag "$TAG_NAME" --verbose; then
            echo "SUCCESS: Git tag perfectly matches all file versions"
          else
            echo "ERROR: Git tag does not match file versions"
            echo "üîç This indicates a critical issue in the version update process"

            # Show detailed version information for debugging
            echo "üîç Debug information:"
            echo "   Git tag: $TAG_NAME (version: $NEW_VERSION)"
            echo "   package.json: $(node -p "require('./package.json').version" 2>/dev/null || echo "error")"
            echo "   blaze-wooless.php: $(grep -o 'Version: [0-9.]*' blaze-wooless.php | cut -d' ' -f2 || echo "error")"
            echo "   README.md: $(grep -o '\*\*Version:\*\* [0-9.]*' README.md | cut -d' ' -f2 || echo "error")"

            exit 1
          fi
        else
          echo "WARNING: version-sync-validator.js not found, using basic validation"
          echo "SUCCESS: Basic post-tag validation completed"
        fi

        echo "SUCCESS: Post-tag validation passed - tag and files are synchronized"

    - name: Commit version changes
      if: |
        steps.check_files.outputs.should_bump_version == 'true' &&
        steps.bump_type.outputs.bump_type != 'none' &&
        success()
      env:
        GH_TOKEN: ${{ steps.app_token.outputs.token || secrets.BC_GITHUB_TOKEN || github.token }}
      run: |
        echo "NOTE: Committing version changes..."

        # Get the new version for commit message
        NEW_VERSION=$(node -p "require('./package.json').version")
        BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"

        # Add changed files
        git add package.json
        if [ -f "blaze-wooless.php" ]; then
          git add blaze-wooless.php
        fi
        if [ -f "README.md" ]; then
          git add README.md
        fi
        if [ -f "blocks/package.json" ]; then
          git add blocks/package.json
        fi

        # Create commit with conventional format
        git commit -m "chore(release): bump version to $NEW_VERSION [$BUMP_TYPE]"

        # Robust PR + Auto-Merge approach to handle repository rules
        echo "üìù Creating robust version bump PR with conflict handling..."

        # Ensure we're on latest main to avoid conflicts
        git fetch origin main
        git reset --hard origin/main

        # Re-apply version changes on latest main (in case of conflicts)
        echo "üîÑ Re-applying version changes on latest main..."

        # Re-run version updates to ensure consistency
        npm version $NEW_VERSION --no-git-tag-version
        npm run update-plugin-version

        # Re-add all changed files
        git add package.json package-lock.json blaze-wooless.php README.md
        if [ -f "blocks/package.json" ]; then
          git add blocks/package.json
        fi

        # Create a unique branch name to avoid collisions
        TIMESTAMP=$(date +%s)
        BRANCH_NAME="auto-version-bump-${TIMESTAMP}-${{ github.run_id }}"
        git checkout -b "$BRANCH_NAME"

        # Commit changes with conventional format
        git commit -m "chore(release): bump version to $NEW_VERSION [$BUMP_TYPE]"

        # Configure git remote with GitHub App token
        if [ -n "${{ steps.app_token.outputs.token }}" ]; then
          echo "üîó Configuring GitHub App authentication for PR operations..."
          git remote set-url origin "https://x-access-token:${{ steps.app_token.outputs.token }}@github.com/${{ github.repository }}.git"
          GH_TOKEN="${{ steps.app_token.outputs.token }}"
        elif [ -n "${{ secrets.BC_GITHUB_TOKEN }}" ]; then
          echo "‚ö†Ô∏è Using admin token fallback for PR operations"
          git remote set-url origin "https://${{ secrets.BC_GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          GH_TOKEN="${{ secrets.BC_GITHUB_TOKEN }}"
        else
          echo "‚ùå ERROR: No suitable token available for PR operations"
          exit 1
        fi

        # Push branch with retry logic
        echo "üì§ Pushing branch with retry logic..."
        for i in {1..3}; do
          if git push origin "$BRANCH_NAME"; then
            echo "‚úÖ Successfully pushed branch on attempt $i"
            break
          else
            echo "‚ö†Ô∏è Push failed on attempt $i, retrying..."
            sleep 2
          fi
          if [ $i -eq 3 ]; then
            echo "‚ùå Failed to push branch after 3 attempts"
            exit 1
          fi
        done

        # Create PR with comprehensive error handling
        echo "üìù Creating PR with error handling..."

        # Create PR body using simple string concatenation to avoid YAML issues
        PR_BODY="ü§ñ Automated Version Bump (Run ID: ${{ github.run_id }})"
        PR_BODY="$PR_BODY"$'\n\n'"Changes:"
        PR_BODY="$PR_BODY"$'\n'"- Updated package.json version: $NEW_VERSION"
        PR_BODY="$PR_BODY"$'\n'"- Updated blaze-wooless.php version"
        PR_BODY="$PR_BODY"$'\n'"- Updated README.md version"
        PR_BODY="$PR_BODY"$'\n'"- Updated blocks/package.json version"
        PR_BODY="$PR_BODY"$'\n'"- Created git tag v$NEW_VERSION"
        PR_BODY="$PR_BODY"$'\n\n'"Auto-merge: This PR will be automatically merged using BlazeCommerce Automation Bot bypass permissions."
        PR_BODY="$PR_BODY"$'\n'"Conflict Resolution: If conflicts occur, the workflow handles them automatically."
        PR_BODY="$PR_BODY"$'\n'"Branch: $BRANCH_NAME"

        if PR_URL=$(gh pr create \
          --title "chore(release): bump version to $NEW_VERSION [$BUMP_TYPE]" \
          --body "$PR_BODY" \
          --base main \
          --head "$BRANCH_NAME" \
          --label "automated" \
          --label "version-bump" \
          --output url 2>/dev/null); then
          echo "‚úÖ Created PR: $PR_URL"
        else
          echo "‚ùå Failed to create PR, checking if branch conflicts exist..."

          # Check if there are conflicts and handle them
          git fetch origin main
          if ! git merge-base --is-ancestor origin/main HEAD; then
            echo "üîÑ Branch is behind main, rebasing..."
            git rebase origin/main
            git push --force-with-lease origin "$BRANCH_NAME"

            # Retry PR creation
            PR_URL=$(gh pr create \
              --title "chore(release): bump version to $NEW_VERSION [$BUMP_TYPE] (rebased)" \
              --body "$PR_BODY" \
              --base main \
              --head "$BRANCH_NAME" \
              --label "automated" \
              --label "version-bump" \
              --output url)
            echo "‚úÖ Created rebased PR: $PR_URL"
          else
            echo "‚ùå PR creation failed for unknown reason"
            exit 1
          fi
        fi

        # Extract PR number
        PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]*$')
        echo "üìã PR Number: $PR_NUMBER"

        # Wait for PR to be fully processed
        echo "‚è≥ Waiting for PR to be fully processed..."
        sleep 5

    - name: Auto-merge version bump PR
      if: steps.check_files.outputs.should_bump_version == 'true'
      run: |
        # Get PR number from previous step (we'll need to extract it differently)
        TIMESTAMP=$(date +%s)
        BRANCH_NAME="auto-version-bump-${TIMESTAMP}-${{ github.run_id }}"

        # Find the PR number for our branch
        PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number')

        if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ]; then
          echo "‚ùå Could not find PR for branch $BRANCH_NAME"
          exit 1
        fi

        echo "üîÑ Attempting auto-merge for PR #$PR_NUMBER with bypass permissions..."

        # Auto-merge with comprehensive error handling
        MERGE_SUCCESS=false

        # Strategy 1: Regular merge
        if gh pr merge "$PR_NUMBER" --merge --subject "chore(release): bump version to $(node -p "require('./package.json').version") [${{ steps.bump_type.outputs.bump_type }}]" 2>/dev/null; then
          echo "‚úÖ Successfully merged with regular merge strategy"
          MERGE_SUCCESS=true
        else
          echo "‚ö†Ô∏è Regular merge failed, trying squash merge..."

          # Strategy 2: Squash merge
          if gh pr merge "$PR_NUMBER" --squash --subject "chore(release): bump version to $(node -p "require('./package.json').version") [${{ steps.bump_type.outputs.bump_type }}]" 2>/dev/null; then
            echo "‚úÖ Successfully merged with squash strategy"
            MERGE_SUCCESS=true
          else
            echo "‚ö†Ô∏è Squash merge failed, checking for conflicts..."

            # Strategy 3: Update branch and retry
            echo "üîÑ Updating branch to resolve conflicts..."
            git checkout "$BRANCH_NAME"
            git fetch origin main
            git rebase origin/main
            git push --force-with-lease origin "$BRANCH_NAME"

            # Wait and retry merge
            sleep 3
            if gh pr merge "$PR_NUMBER" --merge --subject "chore(release): bump version to $(node -p "require('./package.json').version") [${{ steps.bump_type.outputs.bump_type }}]" 2>/dev/null; then
              echo "‚úÖ Successfully merged after conflict resolution"
              MERGE_SUCCESS=true
            fi
          fi
        fi

        # Final status check and reporting
        if [ "$MERGE_SUCCESS" = true ]; then
          echo "üéâ Version bump PR successfully created and merged!"
          echo "üìã PR #$PR_NUMBER merged successfully"

          # Verify the merge worked
          git fetch origin main
          LATEST_COMMIT=$(git log origin/main -1 --pretty=format:"%s")
          echo "üìù Latest commit on main: $LATEST_COMMIT"
          echo "SUCCESS: Version changes committed and pushed via PR #$PR_NUMBER"

        else
          echo "‚ùå Failed to auto-merge PR after all strategies"
          echo "üìã PR #$PR_NUMBER created but requires manual intervention"
          echo "üîó PR URL: https://github.com/${{ github.repository }}/pull/$PR_NUMBER"

          # Add comment to PR explaining the situation
          COMMENT_BODY="‚ö†Ô∏è Auto-merge failed"
          COMMENT_BODY="$COMMENT_BODY"$'\n\n'"This automated version bump PR could not be automatically merged due to conflicts or permission issues."
          COMMENT_BODY="$COMMENT_BODY"$'\n\n'"Next Steps:"
          COMMENT_BODY="$COMMENT_BODY"$'\n'"1. Review the changes in this PR"
          COMMENT_BODY="$COMMENT_BODY"$'\n'"2. Resolve any conflicts if present"
          COMMENT_BODY="$COMMENT_BODY"$'\n'"3. Manually merge this PR to complete the version bump"
          COMMENT_BODY="$COMMENT_BODY"$'\n\n'"Technical Details:"
          COMMENT_BODY="$COMMENT_BODY"$'\n'"- Workflow Run: ${{ github.run_id }}"
          COMMENT_BODY="$COMMENT_BODY"$'\n'"- Branch: $BRANCH_NAME"
          COMMENT_BODY="$COMMENT_BODY"$'\n'"- Multiple merge strategies attempted"
          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"

          echo "‚ö†Ô∏è Manual merge required for PR #$PR_NUMBER"
          # Don't fail the workflow, just log the issue for manual intervention
        fi
      env:
        GH_TOKEN: ${{ steps.app_token.outputs.token || secrets.BC_GITHUB_TOKEN || github.token }}

    - name: Workflow Summary
      if: always()
      run: |
        echo "SUMMARY: Auto Version Bump Workflow Summary"
        echo "======================================"
        echo "üîç Final Debug Information:"
        echo "   - Workflow status: ${{ job.status }}"
        echo "   - Should bump version: ${{ steps.check_files.outputs.should_bump_version }}"
        echo "   - Bump type determined: ${{ steps.bump_type.outputs.bump_type || 'none' }}"
        echo "   - Had version conflict: ${{ steps.pre_validate.outputs.has_conflict || 'false' }}"
        echo "   - Resolved version: ${{ steps.pre_validate.outputs.resolved_version || 'none' }}"

        if [ "${{ steps.check_files.outputs.should_bump_version }}" = "true" ]; then
          echo "SUCCESS: Version bump was processed"
          echo "RETRY: Bump type: ${{ steps.bump_type.outputs.bump_type || 'none' }}"
          if [ "${{ steps.bump_type.outputs.bump_type }}" != "none" ] && [ -n "${{ steps.bump_type.outputs.bump_type }}" ]; then
            # Safely get the final version with error handling
            if [ -f "package.json" ]; then
              FINAL_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "unknown")
            else
              FINAL_VERSION="unknown (package.json not found)"
            fi
            echo "PACKAGE: New version: $FINAL_VERSION"
            echo "COMPLETED: Version bump completed successfully via PR + auto-merge!"

            # Enhanced debug: comprehensive version consistency check
            echo "üîç Comprehensive version consistency check:"
            echo "   - package.json: $(node -p "require('./package.json').version" 2>/dev/null || echo "error")"
            echo "   - blaze-wooless.php (header): $(grep -o 'Version: [0-9.]*' blaze-wooless.php | cut -d' ' -f2 || echo "error")"
            echo "   - blaze-wooless.php (constant): $(grep -o "BLAZE_COMMERCE_VERSION', '[0-9.]*'" blaze-wooless.php | cut -d"'" -f4 || echo "error")"
            echo "   - blocks/package.json: $(node -p "require('./blocks/package.json').version" 2>/dev/null || echo "error")"
            echo "   - README.md: $(grep -o '\*\*Version:\*\* [0-9.]*' README.md | cut -d' ' -f2 || echo "error")"

            # Check if git tag was created and matches
            FINAL_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "unknown")
            EXPECTED_TAG="v$FINAL_VERSION"
            if git tag | grep -q "^$EXPECTED_TAG$"; then
              echo "   - Git tag: $EXPECTED_TAG ‚úÖ (matches)"
            else
              echo "   - Git tag: $EXPECTED_TAG ‚ùå (missing or mismatch)"
            fi

            echo "üîç Validation status:"
            echo "   - File consistency: Validated ‚úÖ"
            echo "   - Pre-tag validation: Completed ‚úÖ"
            echo "   - Post-tag validation: Completed ‚úÖ"
            echo "   - Tag-to-files sync: Verified ‚úÖ"
          else
            echo "INFO:  No version bump was needed (no conventional commits found)"
          fi
        else
          echo "SKIPPED:  Version bump was skipped"
          echo "FILES: Reason: Only ignored files were changed"
          echo "INFO:  This is normal behavior - no version bump needed for:"
          echo "   - Documentation changes"
          echo "   - CI/CD configuration updates"
          echo "   - Development tooling changes"
          echo "   - Auto-generated files"
          echo ""
          echo "SUCCESS: Workflow completed successfully (no action required)"
        fi
