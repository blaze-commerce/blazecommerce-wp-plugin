name: "Priority 3: Auto Version Bump"

on:
  push:
    branches:
      - main
      - develop
      - 'feature/**'
      - 'release/**'

# Priority 3: Post-merge workflow - runs after PR workflows complete
concurrency:
  group: priority-3-auto-version-${{ github.repository }}
  cancel-in-progress: false  # Don't cancel to ensure version consistency

jobs:
  # Wait for Priority 2 (Claude Approval Gate) to complete before proceeding
  wait-for-priority-2:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ vars.PRIORITY_DEPENDENCY_TIMEOUT || 5 }}
    outputs:
      priority-2-completed: ${{ steps.check-dependencies.outputs.all_dependencies_completed }}
    steps:
      - name: Check Priority 2 Dependencies
        id: check-dependencies
        uses: actions/github-script@v7
        with:
          script: |
            console.log('üîç Checking Priority 2 workflow completion...');

            // Get all workflow runs for this commit
            const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: context.sha,
              status: 'completed'
            });

            // Look for completed Priority 2 workflows
            const priority2Workflows = ['Priority 2: Claude AI Approval Gate'];
            let allCompleted = true;

            for (const workflowName of priority2Workflows) {
              const workflow = workflowRuns.workflow_runs.find(run =>
                run.name === workflowName && run.head_sha === context.sha
              );

              if (workflow) {
                console.log(`‚úÖ ${workflowName} completed with status: ${workflow.conclusion}`);
              } else {
                console.log(`‚è≥ ${workflowName} not yet completed`);
                allCompleted = false;
              }
            }

            core.setOutput('all_dependencies_completed', allCompleted.toString());

  version-bump:
    needs: [wait-for-priority-2]
    runs-on: ubuntu-latest
    timeout-minutes: ${{ vars.AUTO_VERSION_TIMEOUT || 20 }}
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, 'chore(release)') && !contains(github.event.head_commit.message, '[no version]')"
    permissions:
      # Minimum required permissions for auto-version workflow
      contents: write         # Required: Update version files and create commits
      pull-requests: read     # Required: Read PR information for version analysis
      actions: read           # Required: Read workflow run information
      # Security: All other permissions explicitly denied (no issues, packages, etc.)

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.BC_GITHUB_TOKEN || github.token }}
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: |
        echo "üîç Installing Node.js dependencies for version management..."

        # Check if package.json exists
        if [ ! -f "package.json" ]; then
          echo "‚ùå package.json not found"
          exit 1
        fi

        # Install dependencies with error handling
        npm install --no-audit --no-fund
        echo "‚úÖ Node.js dependencies installed successfully"

    - name: Check if version bump is needed
      id: check_files
      run: |
        echo "üîç Running file change analysis..."

        # Set environment variables for the script
        export GITHUB_EVENT_BEFORE="${{ github.event.before }}"
        export DEBUG="${{ vars.DEBUG_MODE || 'false' }}"

        # Check if the script exists
        if [ ! -f ".github/scripts/file-change-analyzer.js" ]; then
          echo "‚ö†Ô∏è File change analyzer script not found, using fallback logic..."

          # Simple fallback: check if any significant files changed
          if [ -n "$GITHUB_EVENT_BEFORE" ] && [ "$GITHUB_EVENT_BEFORE" != "0000000000000000000000000000000000000000" ]; then
            CHANGED_FILES=$(git diff --name-only $GITHUB_EVENT_BEFORE..HEAD || echo "")
            if [ -n "$CHANGED_FILES" ]; then
              echo "should_bump_version=true" >> $GITHUB_OUTPUT
              echo "change_reason=Files changed (fallback analysis)" >> $GITHUB_OUTPUT
            else
              echo "should_bump_version=false" >> $GITHUB_OUTPUT
              echo "change_reason=No files changed" >> $GITHUB_OUTPUT
            fi
          else
            echo "should_bump_version=true" >> $GITHUB_OUTPUT
            echo "change_reason=First push or no before commit" >> $GITHUB_OUTPUT
          fi
          echo "‚úÖ Fallback file change analysis completed"
        else
          # Run the extracted file change analyzer
          if node .github/scripts/file-change-analyzer.js >> $GITHUB_OUTPUT; then
            echo "‚úÖ File change analysis completed successfully"
          else
            echo "‚ùå File change analysis failed"
            exit 1
          fi
        fi

    - name: Configure Git
      if: steps.check_files.outputs.should_bump_version == 'true'
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        echo "‚úÖ Git configured for automated commits"

    - name: Run version system tests
      if: steps.check_files.outputs.should_bump_version == 'true'
      run: |
        echo "üß™ Running version system tests..."

        # Check if test script exists before running
        if npm run test:version-system --silent 2>/dev/null; then
          echo "‚úÖ Version system tests passed"
        elif [ $? -eq 127 ] || ! npm run | grep -q "test:version-system"; then
          echo "‚ö†Ô∏è  test:version-system script not found, running fallback validation..."

          # Fallback: Basic validation of core functions
          node -e "
            try {
              const semver = require('./scripts/semver-utils');
              console.log('‚úÖ semver-utils module loads successfully');

              // Test basic functions exist
              if (typeof semver.incrementVersion !== 'function') throw new Error('incrementVersion function missing');
              if (typeof semver.findNextAvailableVersion !== 'function') throw new Error('findNextAvailableVersion function missing');
              if (typeof semver.tagExists !== 'function') throw new Error('tagExists function missing');

              console.log('‚úÖ Core functions are available');
              console.log('‚úÖ Fallback validation passed');
            } catch (error) {
              console.error('‚ùå Fallback validation failed:', error.message);
              process.exit(1);
            }
          "
        else
          echo "‚ùå Version system tests failed. Aborting version bump."
          echo "   Exit code: $?"
          echo "   Please check test implementation and dependencies"
          exit 1
        fi

    - name: Validate current version system
      if: steps.check_files.outputs.should_bump_version == 'true'
      id: version_validation
      run: |
        echo "üîç Running version validation..."

        # Check if the script exists
        if [ ! -f ".github/scripts/version-validator.js" ]; then
          echo "‚ö†Ô∏è Version validator script not found, using fallback logic..."

          # Simple fallback: get version from package.json
          if [ -f "package.json" ]; then
            PACKAGE_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "1.0.0")
            echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
            echo "version_mismatch=false" >> $GITHUB_OUTPUT
            echo "last_tag=" >> $GITHUB_OUTPUT
            echo "‚úÖ Fallback version validation completed"
          else
            echo "‚ùå No package.json found"
            exit 1
          fi
        else
          # Run the extracted version validator
          if node .github/scripts/version-validator.js >> $GITHUB_OUTPUT; then
            echo "‚úÖ Version validation completed successfully"
          else
            echo "‚ùå Version validation failed"
            exit 1
          fi
        fi

    - name: Determine prerelease type based on branch
      if: steps.check_files.outputs.should_bump_version == 'true'
      id: prerelease_type
      run: |
        echo "üåø Running branch analysis..."

        # Set environment variables for the script
        export GITHUB_REF="${{ github.ref }}"

        # Check if the script exists
        if [ ! -f ".github/scripts/branch-analyzer.js" ]; then
          echo "‚ö†Ô∏è Branch analyzer script not found, using fallback logic..."

          # Simple fallback: determine prerelease type from branch name
          BRANCH_NAME=$(echo "$GITHUB_REF" | sed 's|refs/heads/||')

          if [[ "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "master" ]]; then
            echo "prerelease_type=" >> $GITHUB_OUTPUT
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          elif [[ "$BRANCH_NAME" == "develop" ]]; then
            echo "prerelease_type=beta" >> $GITHUB_OUTPUT
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          elif [[ "$BRANCH_NAME" == release/* ]]; then
            echo "prerelease_type=rc" >> $GITHUB_OUTPUT
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "prerelease_type=alpha" >> $GITHUB_OUTPUT
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          fi
          echo "‚úÖ Fallback branch analysis completed"
        else
          # Run the extracted branch analyzer
          if node .github/scripts/branch-analyzer.js >> $GITHUB_OUTPUT; then
            echo "‚úÖ Branch analysis completed successfully"
          else
            echo "‚ùå Branch analysis failed"
            exit 1
          fi
        fi

    - name: Determine version bump type
      if: steps.check_files.outputs.should_bump_version == 'true'
      id: bump_type
      run: |
        echo "üîç Running commit analysis for bump type..."

        # Set environment variables for the script
        export VERSION_MISMATCH="${{ steps.version_validation.outputs.version_mismatch }}"
        export LAST_TAG="${{ steps.version_validation.outputs.last_tag }}"
        export LIMITED_COMMIT_LIMIT="${{ vars.LIMITED_COMMIT_LIMIT || '25' }}"
        export FALLBACK_COMMIT_LIMIT="${{ vars.FALLBACK_COMMIT_LIMIT || '50' }}"

        # Check if the script exists
        if [ ! -f ".github/scripts/bump-type-analyzer.js" ]; then
          echo "‚ö†Ô∏è Bump type analyzer script not found, using fallback logic..."

          # Simple fallback: determine bump type from recent commits
          if [ "$VERSION_MISMATCH" = "true" ]; then
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "reason=Version mismatch fix" >> $GITHUB_OUTPUT
          else
            # Check recent commit messages for conventional commit patterns
            RECENT_COMMITS=$(git log --oneline -10 --pretty=format:"%s" 2>/dev/null || echo "")

            if echo "$RECENT_COMMITS" | grep -qE "^(feat|feature)(\(.+\))?:"; then
              echo "bump_type=minor" >> $GITHUB_OUTPUT
              echo "reason=Feature commits detected" >> $GITHUB_OUTPUT
            elif echo "$RECENT_COMMITS" | grep -qE "^(fix|bugfix|hotfix)(\(.+\))?:"; then
              echo "bump_type=patch" >> $GITHUB_OUTPUT
              echo "reason=Fix commits detected" >> $GITHUB_OUTPUT
            elif echo "$RECENT_COMMITS" | grep -qE "BREAKING CHANGE|!:"; then
              echo "bump_type=major" >> $GITHUB_OUTPUT
              echo "reason=Breaking changes detected" >> $GITHUB_OUTPUT
            else
              echo "bump_type=patch" >> $GITHUB_OUTPUT
              echo "reason=Default patch bump" >> $GITHUB_OUTPUT
            fi
          fi
          echo "‚úÖ Fallback bump type analysis completed"
        else
          # Run the extracted bump type analyzer
          if node .github/scripts/bump-type-analyzer.js "$VERSION_MISMATCH" "$LAST_TAG" >> $GITHUB_OUTPUT; then
            echo "‚úÖ Bump type analysis completed successfully"
          else
            echo "‚ùå Bump type analysis failed"
            exit 1
          fi
        fi

    - name: Execute version bump
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.bump_type != 'none'
      run: |
        echo "üöÄ Executing version bump..."

        # Set environment variables for the script
        export BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"
        export PRERELEASE_TYPE="${{ steps.prerelease_type.outputs.prerelease_type }}"
        export PACKAGE_VERSION="${{ steps.version_validation.outputs.package_version }}"

        # Run the version update script
        if node scripts/update-version.js; then
          echo "‚úÖ Version bump completed successfully"
        else
          echo "‚ùå Version bump failed"
          exit 1
        fi

    - name: Create git tag
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.bump_type != 'none'
      run: |
        echo "üè∑Ô∏è Creating git tag..."

        # Get the new version from package.json
        NEW_VERSION=$(node -p "require('./package.json').version")
        TAG_NAME="v$NEW_VERSION"

        # Create and push tag
        git tag "$TAG_NAME"
        git push origin "$TAG_NAME"

        echo "‚úÖ Created and pushed tag: $TAG_NAME"

    - name: Commit version changes
      if: steps.check_files.outputs.should_bump_version == 'true' && steps.bump_type.outputs.bump_type != 'none'
      run: |
        echo "üìù Committing version changes..."

        # Get the new version for commit message
        NEW_VERSION=$(node -p "require('./package.json').version")
        BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"

        # Add changed files
        git add package.json
        if [ -f "blaze-wooless.php" ]; then
          git add blaze-wooless.php
        fi

        # Create commit with conventional format
        git commit -m "chore(release): bump version to $NEW_VERSION [$BUMP_TYPE]"
        git push

        echo "‚úÖ Version changes committed and pushed"

    - name: Workflow Summary
      if: always()
      run: |
        echo "üìã Auto Version Bump Workflow Summary"
        echo "======================================"

        if [ "${{ steps.check_files.outputs.should_bump_version }}" = "true" ]; then
          echo "‚úÖ Version bump was processed"
          echo "üîÑ Bump type: ${{ steps.bump_type.outputs.bump_type || 'none' }}"
          if [ "${{ steps.bump_type.outputs.bump_type }}" != "none" ] && [ -n "${{ steps.bump_type.outputs.bump_type }}" ]; then
            # Safely get the final version with error handling
            if [ -f "package.json" ]; then
              FINAL_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "unknown")
            else
              FINAL_VERSION="unknown (package.json not found)"
            fi
            echo "üì¶ New version: $FINAL_VERSION"
            echo "üéâ Version bump completed successfully!"
          else
            echo "‚ÑπÔ∏è  No version bump was needed (no conventional commits found)"
          fi
        else
          echo "‚è≠Ô∏è  Version bump was skipped"
          echo "üìÅ Reason: Only ignored files were changed"
          echo "‚ÑπÔ∏è  This is normal behavior - no version bump needed for:"
          echo "   ‚Ä¢ Documentation changes"
          echo "   ‚Ä¢ CI/CD configuration updates"
          echo "   ‚Ä¢ Development tooling changes"
          echo "   ‚Ä¢ Auto-generated files"
          echo ""
          echo "‚úÖ Workflow completed successfully (no action required)"
        fi
